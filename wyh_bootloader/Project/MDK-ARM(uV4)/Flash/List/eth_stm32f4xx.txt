; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\eth_stm32f4xx.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\eth_stm32f4xx.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\RL-ARM\Driver -I..\..\RL-ARM\Config -I..\..\RL-ARM\RL-RTX\inc -I..\..\User\libapp -I..\..\User\bsp\inc -I..\..\User\bsp -I..\..\User -I..\..\Libraries\STM32_USB_Device_Library\Class\dfu\inc -I..\..\Libraries\STM32_USB_Device_Library\Core\inc -D__MICROLIB -D__UVISION_VERSION=518 -D_RTE_ -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx --omf_browse=.\flash\obj\eth_stm32f4xx.crf ..\..\RL-ARM\Driver\ETH_STM32F4xx.c]
                          THUMB

                          AREA ||i.ETH_IRQHandler||, CODE, READONLY, ALIGN=2

                  ETH_IRQHandler PROC
;;;456    */
;;;457    void ETH_IRQHandler (void) 
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;458    {
;;;459    	OS_FRAME *frame;
;;;460    	U32 i, RxLen;
;;;461    	U32 *sp,*dp;
;;;462    
;;;463    	i = RxBufIndex;
000004  4830              LDR      r0,|L1.200|
000006  7804              LDRB     r4,[r0,#0]  ; RxBufIndex
;;;464    	
;;;465    	/* 循环所有接受描述符列表，遇到未接收到数据的退出循环 */
;;;466    	do 
000008  bf00              NOP      
                  |L1.10|
;;;467    	{
;;;468    		/*
;;;469    			#define DMA_RX_ERROR_MASK   (DMA_RX_ES | DMA_RX_LE | DMA_RX_RWT | \
;;;470    								         DMA_RX_RE | DMA_RX_CE)
;;;471    			
;;;472    			有错误，放弃此帧数据，错误类型包含如下：
;;;473    			位15 DMA_RX_ES：错误汇总(Error summary)，即CRC错误，接收错误，看门狗超时，延迟冲突等。
;;;474    		    位12 DMA_RX_LE：长度错误(Length error)
;;;475    		                    该位置1时，指示接收帧的实际长度与长度/类型字段的值不符。该字段仅在帧类
;;;476    		                    型位(RDES0[5])复位后有效。
;;;477    			位4 DMA_RX_RWT：接收看门狗超时 (Receive watchdog timeout)
;;;478    		                    该位置1时，表示接收看门狗计时器在接收当前帧时超时，且当前帧在看门狗超
;;;479    		                    时后被截断了
;;;480    			位3 DMA_RX_RE： 接收错误 (Receive error)
;;;481                                该位置1时，表示在帧接收期间，当发出RX_DV信号时，会发出RX_ERR信号。
;;;482    			位1 DMA_RX_CE： CRC 错误(CRC error)
;;;483                                该位置1时，表示接收的帧发生循环冗余校验(CRC)错误。只有最后一个描述符
;;;484    		                    (RDES0[8])置1时，该字段才有效
;;;485    		*/
;;;486    		if (Rx_Desc[i].Stat & DMA_RX_ERROR_MASK)
00000a  4830              LDR      r0,|L1.204|
00000c  eb001004          ADD      r0,r0,r4,LSL #4
000010  6800              LDR      r0,[r0,#0]
000012  f249011a          MOV      r1,#0x901a
000016  4008              ANDS     r0,r0,r1
000018  b100              CBZ      r0,|L1.28|
;;;487    		{
;;;488    			goto rel;
00001a  e030              B        |L1.126|
                  |L1.28|
;;;489    		}
;;;490    		
;;;491    		/*
;;;492    			#define DMA_RX_SEG_MASK   (DMA_RX_FS | DMA_RX_LS)
;;;493    		    位9 FS：第一个描述符 (First descriptor)
;;;494                        该位置1时，指示此描述符包含帧的第一个缓冲区。如果第一个缓冲区的大小为0，则第二
;;;495                        个缓冲区将包含帧的帧头。如果第二个缓冲区的大小为0，则下一个描述符将包含帧的帧头。
;;;496    		
;;;497    		    位8 LS：最后一个描述符 (Last descriptor)
;;;498                        该位置1时，指示此描述符指向的缓冲区为帧的最后一个缓冲区。
;;;499    		
;;;500    		    下面的函数用于判断此帧数据是否只有一个缓冲，初始化接收描述符列表的时候，每个描述符仅设置了
;;;501    		    一个缓冲。
;;;502    		*/
;;;503    		if ((Rx_Desc[i].Stat & DMA_RX_SEG_MASK) != DMA_RX_SEG_MASK) 
00001c  482b              LDR      r0,|L1.204|
00001e  eb001004          ADD      r0,r0,r4,LSL #4
000022  6800              LDR      r0,[r0,#0]
000024  f4007040          AND      r0,r0,#0x300
000028  f5b07f40          CMP      r0,#0x300
00002c  d000              BEQ      |L1.48|
;;;504    		{
;;;505    			goto rel;
00002e  e026              B        |L1.126|
                  |L1.48|
;;;506    		}
;;;507    		
;;;508    		RxLen = ((Rx_Desc[i].Stat >> 16) & 0x3FFF) - 4;
000030  4826              LDR      r0,|L1.204|
000032  eb001004          ADD      r0,r0,r4,LSL #4
000036  6800              LDR      r0,[r0,#0]
000038  f3c0400d          UBFX     r0,r0,#16,#14
00003c  1f05              SUBS     r5,r0,#4
;;;509    		if (RxLen > ETH_MTU) 
00003e  f24050ea          MOV      r0,#0x5ea
000042  4285              CMP      r5,r0
000044  d900              BLS      |L1.72|
;;;510    		{
;;;511    			/* 数据包太大，直接放弃 */
;;;512    			goto rel;
000046  e01a              B        |L1.126|
                  |L1.72|
;;;513    		}
;;;514    		
;;;515    		/* 申请动态内存，RxLen或上0x80000000表示动态内存不足了不会调用函数sys_error() */
;;;516    		frame = alloc_mem (RxLen | 0x80000000);
000048  f0454000          ORR      r0,r5,#0x80000000
00004c  f7fffffe          BL       alloc_mem
000050  4606              MOV      r6,r0
;;;517    		
;;;518    		/* 如果动态内存申请失败了，放弃此帧数据；成功了，通过函数put_in_queue存入队列中 */
;;;519    		if (frame != NULL) 
000052  b19e              CBZ      r6,|L1.124|
;;;520    		{
;;;521    			sp = (U32 *)(Rx_Desc[i].Addr & ~3);
000054  481d              LDR      r0,|L1.204|
000056  eb001004          ADD      r0,r0,r4,LSL #4
00005a  6880              LDR      r0,[r0,#8]
00005c  f0200703          BIC      r7,r0,#3
;;;522    			dp = (U32 *)&frame->data[0];
000060  f1060804          ADD      r8,r6,#4
;;;523    			for (RxLen = (RxLen + 3) >> 2; RxLen; RxLen--) 
000064  1ce8              ADDS     r0,r5,#3
000066  0885              LSRS     r5,r0,#2
000068  e003              B        |L1.114|
                  |L1.106|
;;;524    			{
;;;525    				*dp++ = *sp++;
00006a  cf01              LDM      r7!,{r0}
00006c  f8480b04          STR      r0,[r8],#4
000070  1e6d              SUBS     r5,r5,#1              ;523
                  |L1.114|
000072  2d00              CMP      r5,#0                 ;523
000074  d1f9              BNE      |L1.106|
;;;526    			}
;;;527    			put_in_queue (frame);
000076  4630              MOV      r0,r6
000078  f7fffffe          BL       put_in_queue
                  |L1.124|
;;;528    		}
;;;529    		
;;;530    		/* 设置此接收描述符继续接收新的数据 */
;;;531    		rel: Rx_Desc[i].Stat = DMA_RX_OWN;
00007c  bf00              NOP      
                  |L1.126|
00007e  f04f4000          MOV      r0,#0x80000000
000082  4912              LDR      r1,|L1.204|
000084  eb011104          ADD      r1,r1,r4,LSL #4
000088  6008              STR      r0,[r1,#0]
;;;532    
;;;533    		if (++i == NUM_RX_BUF) i = 0;
00008a  1c60              ADDS     r0,r4,#1
00008c  4604              MOV      r4,r0
00008e  2804              CMP      r0,#4
000090  d100              BNE      |L1.148|
000092  2400              MOVS     r4,#0
                  |L1.148|
;;;534    	}
;;;535    	while (!(Rx_Desc[i].Stat & DMA_RX_OWN));
000094  480d              LDR      r0,|L1.204|
000096  eb001004          ADD      r0,r0,r4,LSL #4
00009a  6800              LDR      r0,[r0,#0]
00009c  f0004000          AND      r0,r0,#0x80000000
0000a0  2800              CMP      r0,#0
0000a2  d0b2              BEQ      |L1.10|
;;;536    	
;;;537    	RxBufIndex = i;
0000a4  4908              LDR      r1,|L1.200|
0000a6  700c              STRB     r4,[r1,#0]
;;;538    
;;;539    	/*
;;;540    	   DMASR DMA的状态寄存器（DMA status register）
;;;541    	   位7 RBUS：接收缓冲区不可用状态 (Receive buffer unavailable status)
;;;542                     此位指示接收列表中的下一个描述符由CPU所拥有，DMA无法获取。接收过程进入挂起状态。
;;;543    	             要恢复处理接收描述符，CPU应更改描述符的拥有关系，然后发出接收轮询请求命令。如果
;;;544    	             未发出接收轮询请求命令，则当接收到下一个识别的传入帧时，接收过程会恢复。仅当上一
;;;545    	             接收描述符由DMA所拥有时，才能将ETH_DMASR[7]置1。
;;;546    	
;;;547    	   DMAIER的接收缓冲区不可用中断RBUIE是bit7，对于的接收缓冲区不可用状态在DMA状态寄存器中也是bit7。
;;;548    	*/
;;;549    	if (ETH->DMASR & INT_RBUIE) 
0000a8  4809              LDR      r0,|L1.208|
0000aa  6940              LDR      r0,[r0,#0x14]
0000ac  f0000080          AND      r0,r0,#0x80
0000b0  b120              CBZ      r0,|L1.188|
;;;550    	{
;;;551    		/* 接收缓冲区不可用，重新恢复DMA传输 */
;;;552    		ETH->DMASR = ETH_DMASR_RBUS;
0000b2  2080              MOVS     r0,#0x80
0000b4  4906              LDR      r1,|L1.208|
0000b6  6148              STR      r0,[r1,#0x14]
;;;553    		ETH->DMARPDR = 0;
0000b8  2000              MOVS     r0,#0
0000ba  6088              STR      r0,[r1,#8]
                  |L1.188|
;;;554    	}
;;;555    	
;;;556    	/* 
;;;557    	   DMASR DMA的状态寄存器（DMA status register）
;;;558    	   这里实现清除中断挂起标志 
;;;559    	   位16 ETH_DMASR_NIS：所有正常中断 (Normal interrupt summary)
;;;560    	   位15 ETH_DMASR_AIS：所有异常中断 (Abnormal interrupt summary)
;;;561    	   位6  ETH_DMASR_RS ：接收状态 (Receive status)
;;;562    	                       此位指示帧接收已完成，具体的帧状态信息已经包含在描述符中，接收仍保持运行状态。
;;;563    	*/
;;;564    	ETH->DMASR = ETH_DMASR_NIS | ETH_DMASR_AIS | ETH_DMASR_RS;
0000bc  4805              LDR      r0,|L1.212|
0000be  4904              LDR      r1,|L1.208|
0000c0  6148              STR      r0,[r1,#0x14]
;;;565    }
0000c2  e8bd81f0          POP      {r4-r8,pc}
;;;566    
                          ENDP

0000c6  0000              DCW      0x0000
                  |L1.200|
                          DCD      RxBufIndex
                  |L1.204|
                          DCD      Rx_Desc
                  |L1.208|
                          DCD      0x40029000
                  |L1.212|
                          DCD      0x00018040

                          AREA ||i.EXTI9_5_IRQHandler||, CODE, READONLY, ALIGN=2

                  EXTI9_5_IRQHandler PROC
;;;812    #define ETH_DISCONNECT "ETH_LINK Disconnect\r\n"
;;;813    void EXTI9_5_IRQHandler(void)
000000  b570              PUSH     {r4-r6,lr}
;;;814    {
;;;815    	U32 regv, tout;
;;;816    	
;;;817    	if (EXTI_GetITStatus(EXTI_Line6) != RESET)
000002  2040              MOVS     r0,#0x40
000004  f7fffffe          BL       EXTI_GetITStatus
000008  2800              CMP      r0,#0
00000a  d045              BEQ      |L2.152|
;;;818    	{
;;;819    		/* 可以考虑在此处加入延迟，有时连接状态变了，但是寄存器没有及时更新*/
;;;820    		regv = read_PHY(PHY_REG_INTERRUPT);
00000c  2015              MOVS     r0,#0x15
00000e  f7fffffe          BL       read_PHY
000012  4604              MOV      r4,r0
;;;821    		if(regv & (1 << 2))
000014  f0040004          AND      r0,r4,#4
000018  2800              CMP      r0,#0
00001a  d03a              BEQ      |L2.146|
;;;822    		{
;;;823    			/* 重新插入后要多读几次，保证寄存器BMSR被更新 */
;;;824    			for(tout = 0; tout < 10; tout++) 
00001c  2500              MOVS     r5,#0
00001e  e008              B        |L2.50|
                  |L2.32|
;;;825    			{
;;;826    				regv = read_PHY (PHY_REG_BMSR);
000020  2001              MOVS     r0,#1
000022  f7fffffe          BL       read_PHY
000026  4604              MOV      r4,r0
;;;827    				if (regv & (1 << 2)) 
000028  f0040004          AND      r0,r4,#4
00002c  b100              CBZ      r0,|L2.48|
;;;828    				{
;;;829    					break;
00002e  e002              B        |L2.54|
                  |L2.48|
000030  1c6d              ADDS     r5,r5,#1              ;824
                  |L2.50|
000032  2d0a              CMP      r5,#0xa               ;824
000034  d3f4              BCC      |L2.32|
                  |L2.54|
000036  bf00              NOP      
;;;830    				}
;;;831    			}
;;;832    
;;;833    			/* 连接上网线 */
;;;834    			if(regv & (1 << 2)) 
000038  f0040004          AND      r0,r4,#4
00003c  b1a0              CBZ      r0,|L2.104|
;;;835    			{
;;;836    				#ifdef ETH_CONSTATUS
;;;837    					const char *pError = ETH_CONNECT;
00003e  a117              ADR      r1,|L2.156|
;;;838    					uint8_t i;
;;;839    				#endif
;;;840    				
;;;841    				g_ucEthLinkStatus = 1;
000040  2201              MOVS     r2,#1
000042  4b1b              LDR      r3,|L2.176|
000044  701a              STRB     r2,[r3,#0]
;;;842    				
;;;843    				#ifdef ETH_CONSTATUS
;;;844    					for (i = 0; i < sizeof(ETH_CONNECT); i++)
000046  2000              MOVS     r0,#0
000048  e00b              B        |L2.98|
                  |L2.74|
;;;845    					{
;;;846    						USART1->DR = pError[i];
00004a  5c0a              LDRB     r2,[r1,r0]
00004c  4b19              LDR      r3,|L2.180|
00004e  809a              STRH     r2,[r3,#4]
;;;847    						/* 等待发送结束 */
;;;848    						while ((USART1->SR & USART_FLAG_TC) == (uint16_t)RESET);
000050  bf00              NOP      
                  |L2.82|
000052  4a18              LDR      r2,|L2.180|
000054  8812              LDRH     r2,[r2,#0]
000056  f0020240          AND      r2,r2,#0x40
00005a  2a00              CMP      r2,#0
00005c  d0f9              BEQ      |L2.82|
00005e  1c42              ADDS     r2,r0,#1              ;844
000060  b2d0              UXTB     r0,r2                 ;844
                  |L2.98|
000062  2813              CMP      r0,#0x13              ;844
000064  d3f1              BCC      |L2.74|
;;;849    					}
;;;850    				#endif 
;;;851    			}
000066  e014              B        |L2.146|
                  |L2.104|
;;;852    			/* 网线断开 */
;;;853    			else
;;;854    			{
;;;855    				#ifdef ETH_CONSTATUS
;;;856    					const char *pError = ETH_DISCONNECT;
000068  a113              ADR      r1,|L2.184|
;;;857    					uint8_t i;
;;;858    				#endif
;;;859    				
;;;860    				g_ucEthLinkStatus = 0;
00006a  2200              MOVS     r2,#0
00006c  4b10              LDR      r3,|L2.176|
00006e  701a              STRB     r2,[r3,#0]
;;;861    				
;;;862    				#ifdef ETH_CONSTATUS
;;;863    					for (i = 0; i < sizeof(ETH_DISCONNECT); i++)
000070  2000              MOVS     r0,#0
000072  e00b              B        |L2.140|
                  |L2.116|
;;;864    					{
;;;865    						USART1->DR = pError[i];
000074  5c0a              LDRB     r2,[r1,r0]
000076  4b0f              LDR      r3,|L2.180|
000078  809a              STRH     r2,[r3,#4]
;;;866    						/* 等待发送结束 */
;;;867    						while ((USART1->SR & USART_FLAG_TC) == (uint16_t)RESET);
00007a  bf00              NOP      
                  |L2.124|
00007c  4a0d              LDR      r2,|L2.180|
00007e  8812              LDRH     r2,[r2,#0]
000080  f0020240          AND      r2,r2,#0x40
000084  2a00              CMP      r2,#0
000086  d0f9              BEQ      |L2.124|
000088  1c42              ADDS     r2,r0,#1              ;863
00008a  b2d0              UXTB     r0,r2                 ;863
                  |L2.140|
00008c  2816              CMP      r0,#0x16              ;863
00008e  d3f1              BCC      |L2.116|
;;;868    					}
;;;869    				#endif
;;;870    				
;;;871    			}
000090  bf00              NOP      
                  |L2.146|
;;;872    			
;;;873    		}
;;;874    		/* 清中断挂起位 */
;;;875    		EXTI_ClearITPendingBit(EXTI_Line6);
000092  2040              MOVS     r0,#0x40
000094  f7fffffe          BL       EXTI_ClearITPendingBit
                  |L2.152|
;;;876    	}
;;;877    }
000098  bd70              POP      {r4-r6,pc}
;;;878    
                          ENDP

00009a  0000              DCW      0x0000
                  |L2.156|
00009c  4554485f          DCB      "ETH_LINK Connect\r\n",0
0000a0  4c494e4b
0000a4  20436f6e
0000a8  6e656374
0000ac  0d0a00  
0000af  00                DCB      0
                  |L2.176|
                          DCD      g_ucEthLinkStatus
                  |L2.180|
                          DCD      0x40011000
                  |L2.184|
0000b8  4554485f          DCB      "ETH_LINK Disconnect\r\n",0
0000bc  4c494e4b
0000c0  20446973
0000c4  636f6e6e
0000c8  6563740d
0000cc  0a00    
0000ce  00                DCB      0
0000cf  00                DCB      0

                          AREA ||i.Eth_Link_EXTIConfig||, CODE, READONLY, ALIGN=2

                  Eth_Link_EXTIConfig PROC
;;;766    */
;;;767    static void Eth_Link_EXTIConfig(void)
000000  b500              PUSH     {lr}
;;;768    {
000002  b085              SUB      sp,sp,#0x14
;;;769    	GPIO_InitTypeDef GPIO_InitStructure;
;;;770    	EXTI_InitTypeDef EXTI_InitStructure;
;;;771    	NVIC_InitTypeDef NVIC_InitStructure;
;;;772    
;;;773    	/* 安富莱STM32-V6开发板使用PH6作为中断输入口, 下降沿表示中断信号 */
;;;774    	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOH, ENABLE);
000004  2101              MOVS     r1,#1
000006  2080              MOVS     r0,#0x80
000008  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;775    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
00000c  2101              MOVS     r1,#1
00000e  0388              LSLS     r0,r1,#14
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;776    
;;;777    	/* 配置中断引脚是输入 */
;;;778    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
000014  2000              MOVS     r0,#0
000016  f88d0010          STRB     r0,[sp,#0x10]
;;;779    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
00001a  f88d0012          STRB     r0,[sp,#0x12]
;;;780    	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
00001e  f88d0013          STRB     r0,[sp,#0x13]
;;;781    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
000022  2040              MOVS     r0,#0x40
000024  9003              STR      r0,[sp,#0xc]
;;;782    	GPIO_Init(GPIOH, &GPIO_InitStructure);
000026  a903              ADD      r1,sp,#0xc
000028  4812              LDR      r0,|L3.116|
00002a  f7fffffe          BL       GPIO_Init
;;;783    
;;;784    	/* 配置外部中断线连接到相应引脚 */
;;;785    	SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOH, EXTI_PinSource6);
00002e  2106              MOVS     r1,#6
000030  2007              MOVS     r0,#7
000032  f7fffffe          BL       SYSCFG_EXTILineConfig
;;;786    
;;;787    	/* 配置外部中断线 */
;;;788    	EXTI_InitStructure.EXTI_Line = EXTI_Line6;
000036  2040              MOVS     r0,#0x40
000038  9001              STR      r0,[sp,#4]
;;;789    	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
00003a  2000              MOVS     r0,#0
00003c  f88d0008          STRB     r0,[sp,#8]
;;;790    	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
000040  200c              MOVS     r0,#0xc
000042  f88d0009          STRB     r0,[sp,#9]
;;;791    	EXTI_InitStructure.EXTI_LineCmd = ENABLE;
000046  2001              MOVS     r0,#1
000048  f88d000a          STRB     r0,[sp,#0xa]
;;;792    	EXTI_Init(&EXTI_InitStructure);
00004c  a801              ADD      r0,sp,#4
00004e  f7fffffe          BL       EXTI_Init
;;;793    
;;;794    	/* 使能中断通道 */
;;;795    	NVIC_InitStructure.NVIC_IRQChannel = EXTI9_5_IRQn;
000052  2017              MOVS     r0,#0x17
000054  f88d0000          STRB     r0,[sp,#0]
;;;796    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
000058  2001              MOVS     r0,#1
00005a  f88d0001          STRB     r0,[sp,#1]
;;;797    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
00005e  2000              MOVS     r0,#0
000060  f88d0002          STRB     r0,[sp,#2]
;;;798    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000064  2001              MOVS     r0,#1
000066  f88d0003          STRB     r0,[sp,#3]
;;;799    	NVIC_Init(&NVIC_InitStructure);
00006a  4668              MOV      r0,sp
00006c  f7fffffe          BL       NVIC_Init
;;;800    }
000070  b005              ADD      sp,sp,#0x14
000072  bd00              POP      {pc}
;;;801    
                          ENDP

                  |L3.116|
                          DCD      0x40021c00

                          AREA ||i.init_ethernet||, CODE, READONLY, ALIGN=2

                  init_ethernet PROC
;;;123    */
;;;124    void init_ethernet (void) 
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;125    {
;;;126    	U32 regv,tout,conn; 
;;;127    
;;;128    	/* 关闭PHY中断触发引脚 */
;;;129    	NVIC_DisableIRQ(EXTI9_5_IRQn);
000004  2017              MOVS     r0,#0x17
000006  2101              MOVS     r1,#1
000008  4081              LSLS     r1,r1,r0
00000a  4ac9              LDR      r2,|L4.816|
00000c  0943              LSRS     r3,r0,#5
00000e  f8421023          STR      r1,[r2,r3,LSL #2]
000012  bf00              NOP      
;;;130    
;;;131    	/* 使能系统配置控制器时钟 */
;;;132    	RCC->APB2ENR |= (1 << 14);
000014  48c7              LDR      r0,|L4.820|
000016  6800              LDR      r0,[r0,#0]
000018  f4404080          ORR      r0,r0,#0x4000
00001c  49c5              LDR      r1,|L4.820|
00001e  6008              STR      r0,[r1,#0]
;;;133    
;;;134    	/* 复位以太网MAC */
;;;135    	RCC->AHB1RSTR |=  0x02000000;
000020  48c4              LDR      r0,|L4.820|
000022  3834              SUBS     r0,r0,#0x34
000024  6800              LDR      r0,[r0,#0]
000026  f0407000          ORR      r0,r0,#0x2000000
00002a  49c2              LDR      r1,|L4.820|
00002c  3934              SUBS     r1,r1,#0x34
00002e  6008              STR      r0,[r1,#0]
;;;136    
;;;137    	/* 选择RMII接口，必须在 MAC 处于复位状态且在使能 MAC 时钟之前完成此配置 */
;;;138    	SYSCFG->PMC |=  (1 << 23);
000030  48c1              LDR      r0,|L4.824|
000032  6800              LDR      r0,[r0,#0]
000034  f4400000          ORR      r0,r0,#0x800000
000038  49bf              LDR      r1,|L4.824|
00003a  6008              STR      r0,[r1,#0]
;;;139    
;;;140    	/* 停止复位以太网MAC */
;;;141    	RCC->AHB1RSTR &= ~0x02000000;
00003c  48bd              LDR      r0,|L4.820|
00003e  3834              SUBS     r0,r0,#0x34
000040  6800              LDR      r0,[r0,#0]
000042  f0207000          BIC      r0,r0,#0x2000000
000046  49bb              LDR      r1,|L4.820|
000048  3934              SUBS     r1,r1,#0x34
00004a  6008              STR      r0,[r1,#0]
;;;142    
;;;143    	/* 使能以太网时钟，GPIOA，GPIOB，GPIOC，GPIOG时钟 */
;;;144    	RCC->AHB1ENR |= 0x1E000047;
00004c  48b9              LDR      r0,|L4.820|
00004e  3814              SUBS     r0,r0,#0x14
000050  6800              LDR      r0,[r0,#0]
000052  49ba              LDR      r1,|L4.828|
000054  4308              ORRS     r0,r0,r1
000056  49b7              LDR      r1,|L4.820|
000058  3914              SUBS     r1,r1,#0x14
00005a  6008              STR      r0,[r1,#0]
;;;145    
;;;146    	/* 原始驱动还配置了PA8，用于给PHY芯片提供时钟，V6开发板外置有源晶振，无需配置PA8 */
;;;147    	/* 配置PA1，PA2和PA7，复用功能，推挽模式，100MHz，无上拉下拉，复用到AF11 (Ethernet) */
;;;148    	GPIOA->MODER   &= ~0x0000C03C;
00005c  48b8              LDR      r0,|L4.832|
00005e  6800              LDR      r0,[r0,#0]
000060  f24c013c          MOV      r1,#0xc03c
000064  4388              BICS     r0,r0,r1
000066  49b6              LDR      r1,|L4.832|
000068  6008              STR      r0,[r1,#0]
;;;149    	GPIOA->MODER   |=  0x00008028;              
00006a  4608              MOV      r0,r1
00006c  6800              LDR      r0,[r0,#0]
00006e  f2480128          MOV      r1,#0x8028
000072  4308              ORRS     r0,r0,r1
000074  49b2              LDR      r1,|L4.832|
000076  6008              STR      r0,[r1,#0]
;;;150    	GPIOA->OTYPER  &= ~0x00000086;              
000078  4608              MOV      r0,r1
00007a  6840              LDR      r0,[r0,#4]
00007c  f0200086          BIC      r0,r0,#0x86
000080  6048              STR      r0,[r1,#4]
;;;151    	GPIOA->OSPEEDR |=  0x0003C03C;              
000082  4608              MOV      r0,r1
000084  6880              LDR      r0,[r0,#8]
000086  49af              LDR      r1,|L4.836|
000088  4308              ORRS     r0,r0,r1
00008a  49ad              LDR      r1,|L4.832|
00008c  6088              STR      r0,[r1,#8]
;;;152    	GPIOA->PUPDR   &= ~0x0003C03C;             
00008e  4608              MOV      r0,r1
000090  68c0              LDR      r0,[r0,#0xc]
000092  49ac              LDR      r1,|L4.836|
000094  43c9              MVNS     r1,r1
000096  4008              ANDS     r0,r0,r1
000098  49a9              LDR      r1,|L4.832|
00009a  60c8              STR      r0,[r1,#0xc]
;;;153    	GPIOA->AFR[0]  &= ~0xF0000FF0;
00009c  4608              MOV      r0,r1
00009e  6a00              LDR      r0,[r0,#0x20]
0000a0  49a9              LDR      r1,|L4.840|
0000a2  4008              ANDS     r0,r0,r1
0000a4  49a6              LDR      r1,|L4.832|
0000a6  6208              STR      r0,[r1,#0x20]
;;;154    	GPIOA->AFR[0]  |=  0xB0000BB0;              
0000a8  4608              MOV      r0,r1
0000aa  6a00              LDR      r0,[r0,#0x20]
0000ac  49a7              LDR      r1,|L4.844|
0000ae  4308              ORRS     r0,r0,r1
0000b0  49a3              LDR      r1,|L4.832|
0000b2  6208              STR      r0,[r1,#0x20]
;;;155    
;;;156    	/* 配置PC1，PC4和PC5，复用功能，推挽模式，100MHz，无上拉下拉，复用到AF11 (Ethernet) */
;;;157    	GPIOC->MODER   &= ~0x00000F0C;
0000b4  48a6              LDR      r0,|L4.848|
0000b6  6800              LDR      r0,[r0,#0]
0000b8  f640710c          MOV      r1,#0xf0c
0000bc  4388              BICS     r0,r0,r1
0000be  49a4              LDR      r1,|L4.848|
0000c0  6008              STR      r0,[r1,#0]
;;;158    	GPIOC->MODER   |=  0x00000A08;             
0000c2  4608              MOV      r0,r1
0000c4  6800              LDR      r0,[r0,#0]
0000c6  f6402108          MOV      r1,#0xa08
0000ca  4308              ORRS     r0,r0,r1
0000cc  49a0              LDR      r1,|L4.848|
0000ce  6008              STR      r0,[r1,#0]
;;;159    	GPIOC->OTYPER  &= ~0x00000032;              
0000d0  1d08              ADDS     r0,r1,#4
0000d2  6800              LDR      r0,[r0,#0]
0000d4  f0200032          BIC      r0,r0,#0x32
0000d8  1d09              ADDS     r1,r1,#4
0000da  6008              STR      r0,[r1,#0]
;;;160    	GPIOC->OSPEEDR |=  0x00000F0C;              
0000dc  1d08              ADDS     r0,r1,#4
0000de  6800              LDR      r0,[r0,#0]
0000e0  f640710c          MOV      r1,#0xf0c
0000e4  4308              ORRS     r0,r0,r1
0000e6  499a              LDR      r1,|L4.848|
0000e8  3108              ADDS     r1,r1,#8
0000ea  6008              STR      r0,[r1,#0]
;;;161    	GPIOC->PUPDR   &= ~0x00000F0C;            
0000ec  1d08              ADDS     r0,r1,#4
0000ee  6800              LDR      r0,[r0,#0]
0000f0  f640710c          MOV      r1,#0xf0c
0000f4  4388              BICS     r0,r0,r1
0000f6  4996              LDR      r1,|L4.848|
0000f8  310c              ADDS     r1,r1,#0xc
0000fa  6008              STR      r0,[r1,#0]
;;;162    	GPIOC->AFR[0]  &= ~0x00FF00F0;
0000fc  4894              LDR      r0,|L4.848|
0000fe  3020              ADDS     r0,r0,#0x20
000100  6800              LDR      r0,[r0,#0]
000102  4994              LDR      r1,|L4.852|
000104  4008              ANDS     r0,r0,r1
000106  4992              LDR      r1,|L4.848|
000108  3120              ADDS     r1,r1,#0x20
00010a  6008              STR      r0,[r1,#0]
;;;163    	GPIOC->AFR[0]  |=  0x00BB00B0;              
00010c  4608              MOV      r0,r1
00010e  6800              LDR      r0,[r0,#0]
000110  4991              LDR      r1,|L4.856|
000112  4308              ORRS     r0,r0,r1
000114  498e              LDR      r1,|L4.848|
000116  3120              ADDS     r1,r1,#0x20
000118  6008              STR      r0,[r1,#0]
;;;164    
;;;165    	/* 配置PG11，PG13和PG14，复用功能，推挽模式，100MHz，无上拉下拉，复用到AF11 (Ethernet) */
;;;166    	GPIOG->MODER   &= ~0x3CC00000;
00011a  4890              LDR      r0,|L4.860|
00011c  6800              LDR      r0,[r0,#0]
00011e  f0205073          BIC      r0,r0,#0x3cc00000
000122  498e              LDR      r1,|L4.860|
000124  6008              STR      r0,[r1,#0]
;;;167    	GPIOG->MODER   |=  0x28800000;             
000126  4608              MOV      r0,r1
000128  6800              LDR      r0,[r0,#0]
00012a  f0405022          ORR      r0,r0,#0x28800000
00012e  6008              STR      r0,[r1,#0]
;;;168    	GPIOG->OTYPER  &= ~0x00006800;             
000130  1d08              ADDS     r0,r1,#4
000132  6800              LDR      r0,[r0,#0]
000134  f42040d0          BIC      r0,r0,#0x6800
000138  1d09              ADDS     r1,r1,#4
00013a  6008              STR      r0,[r1,#0]
;;;169    	GPIOG->OSPEEDR |=  0x3CC00000;           
00013c  1d08              ADDS     r0,r1,#4
00013e  6800              LDR      r0,[r0,#0]
000140  f0405073          ORR      r0,r0,#0x3cc00000
000144  1d09              ADDS     r1,r1,#4
000146  6008              STR      r0,[r1,#0]
;;;170    	GPIOG->PUPDR   &= ~0x3CC00000;            
000148  1d08              ADDS     r0,r1,#4
00014a  6800              LDR      r0,[r0,#0]
00014c  f0205073          BIC      r0,r0,#0x3cc00000
000150  1d09              ADDS     r1,r1,#4
000152  6008              STR      r0,[r1,#0]
;;;171    	GPIOG->AFR[1]  &= ~0x0FF0F000;
000154  4881              LDR      r0,|L4.860|
000156  6a40              LDR      r0,[r0,#0x24]
000158  4981              LDR      r1,|L4.864|
00015a  4008              ANDS     r0,r0,r1
00015c  497f              LDR      r1,|L4.860|
00015e  6248              STR      r0,[r1,#0x24]
;;;172    	GPIOG->AFR[1]  |=  0x0BB0B000;             
000160  4608              MOV      r0,r1
000162  6a40              LDR      r0,[r0,#0x24]
000164  497f              LDR      r1,|L4.868|
000166  4308              ORRS     r0,r0,r1
000168  497c              LDR      r1,|L4.860|
00016a  6248              STR      r0,[r1,#0x24]
;;;173    
;;;174    	/* 
;;;175    	  寄存器ETH->DMABMR的SR位置1后，MAC DMA控制器会复位所有MAC子系统的内部寄存器和逻辑。在所有内
;;;176    	  核时钟域完成复位操作后，该位自动清零。重新编程任何内核寄存器之前，在该位中读取0 值。
;;;177    	*/
;;;178    	ETH->DMABMR  |= DBMR_SR;
00016c  487e              LDR      r0,|L4.872|
00016e  6800              LDR      r0,[r0,#0]
000170  f0400001          ORR      r0,r0,#1
000174  497c              LDR      r1,|L4.872|
000176  6008              STR      r0,[r1,#0]
;;;179    	while (ETH->DMABMR & DBMR_SR);
000178  bf00              NOP      
                  |L4.378|
00017a  487b              LDR      r0,|L4.872|
00017c  6800              LDR      r0,[r0,#0]
00017e  f0000001          AND      r0,r0,#1
000182  2800              CMP      r0,#0
000184  d1f9              BNE      |L4.378|
;;;180    	conn = 0;
000186  2600              MOVS     r6,#0
;;;181    
;;;182    	/* 
;;;183    	   HCLK的时钟是168MHz，这里选项CR位为100，CR占用寄存器ETH->MACMIIAR的bit4，bit3和bit2。
;;;184    	   CR 时钟范围选项可确定 HCLK 频率并用于决定 MDC 时钟频率：
;;;185    	    选项     HCLK        MDC 时钟
;;;186    	    000    60-100MHz     HCLK/42
;;;187    		001    100-150MHz    HCLK/62
;;;188    		010    20-35MHz      HCLK/16
;;;189    		011    35-60MHz      HCLK/26
;;;190    		100    150-168MHz    HCLK/102
;;;191    		101、110、111 保留
;;;192        */
;;;193    	ETH->MACMIIAR = 0x00000010;
000188  2010              MOVS     r0,#0x10
00018a  4978              LDR      r1,|L4.876|
00018c  6108              STR      r0,[r1,#0x10]
;;;194    
;;;195    	/*
;;;196    	  注意事项：DM9161可以上电后就读取其ID寄存器，但是DM9162不行，需要延迟一段时间这里为了方便起见，
;;;197    	  直接将其复位，发送复位指令可以立即执行。
;;;198    	*/
;;;199    	/* 第1步：复位DM9161/9162 ***********************************************************/
;;;200    	printf_eth("===============================================================\r\n");
00018e  4878              LDR      r0,|L4.880|
000190  f7fffffe          BL       __2printf
;;;201    	printf_eth("下面是DM9161/9162的硬件初始化：\r\n");
000194  a077              ADR      r0,|L4.884|
000196  f7fffffe          BL       __2printf
;;;202    	printf_eth("1. Start PHY_ID_DM9161/9162 Init\r\n");
00019a  a07f              ADR      r0,|L4.920|
00019c  f7fffffe          BL       __2printf
;;;203    	
;;;204    	/* 发送复位命令 */
;;;205    	write_PHY (PHY_REG_BMCR, 0x8000);
0001a0  f44f4100          MOV      r1,#0x8000
0001a4  2000              MOVS     r0,#0
0001a6  f7fffffe          BL       write_PHY
;;;206    
;;;207    	/* 等待复位完成 */
;;;208    	for (tout = 0; tout < 0x10000; tout++) 
0001aa  2500              MOVS     r5,#0
0001ac  e00b              B        |L4.454|
                  |L4.430|
;;;209    	{
;;;210    		regv = read_PHY (PHY_REG_BMCR);
0001ae  2000              MOVS     r0,#0
0001b0  f7fffffe          BL       read_PHY
0001b4  4604              MOV      r4,r0
;;;211    		if (!(regv & 0x8800)) 
0001b6  f4044008          AND      r0,r4,#0x8800
0001ba  b918              CBNZ     r0,|L4.452|
;;;212    		{
;;;213    			/* 复位完成 */
;;;214    			printf_eth("2. Reset Complete\r\n");
0001bc  a07f              ADR      r0,|L4.956|
0001be  f7fffffe          BL       __2printf
;;;215    			break;
0001c2  e003              B        |L4.460|
                  |L4.452|
0001c4  1c6d              ADDS     r5,r5,#1              ;208
                  |L4.454|
0001c6  f5b53f80          CMP      r5,#0x10000           ;208
0001ca  d3f0              BCC      |L4.430|
                  |L4.460|
0001cc  bf00              NOP      
;;;216    		}
;;;217    	}
;;;218    
;;;219    	/* 第2步：配置DM9161/9162 ***********************************************************/
;;;220    #if defined (_10MBIT_)
;;;221    	write_PHY (PHY_REG_BMCR, PHY_FULLD_10M);  /* 连接到10Mbps的网络 */
;;;222    #elif defined (_100MBIT_)
;;;223    	write_PHY (PHY_REG_BMCR, PHY_FULLD_100M); /* 连接到100Mbps的网络 */
;;;224    #else
;;;225    	/* 通过Auto-Negotiation实现自适应10Mbps网络或者100Mbps网络 */
;;;226    	write_PHY (PHY_REG_BMCR, PHY_AUTO_NEG);
0001ce  f44f5180          MOV      r1,#0x1000
0001d2  2000              MOVS     r0,#0
0001d4  f7fffffe          BL       write_PHY
;;;227    	
;;;228    	/* 等待完成Auto-Negotiation */
;;;229    	for (tout = 0; tout < 0x100000; tout++) 
0001d8  2500              MOVS     r5,#0
0001da  e00b              B        |L4.500|
                  |L4.476|
;;;230    	{
;;;231    		regv = read_PHY (PHY_REG_BMSR);
0001dc  2001              MOVS     r0,#1
0001de  f7fffffe          BL       read_PHY
0001e2  4604              MOV      r4,r0
;;;232    		if (regv & 0x0020) 
0001e4  f0040020          AND      r0,r4,#0x20
0001e8  b118              CBZ      r0,|L4.498|
;;;233    		{
;;;234    			/* 完成Auto-Negotiation */
;;;235    			printf_eth("3. Auto-Negotiation Complete\r\n");
0001ea  a079              ADR      r0,|L4.976|
0001ec  f7fffffe          BL       __2printf
;;;236    			break;
0001f0  e003              B        |L4.506|
                  |L4.498|
0001f2  1c6d              ADDS     r5,r5,#1              ;229
                  |L4.500|
0001f4  f5b51f80          CMP      r5,#0x100000          ;229
0001f8  d3f0              BCC      |L4.476|
                  |L4.506|
0001fa  bf00              NOP      
;;;237    		}
;;;238    	}
;;;239    #endif
;;;240    	
;;;241    	/* 第3步：检测连接状态 ***********************************************************/
;;;242    	for (tout = 0; tout < 0x10000; tout++) 
0001fc  2500              MOVS     r5,#0
0001fe  e02f              B        |L4.608|
                  |L4.512|
;;;243    	{
;;;244    		regv = read_PHY (PHY_REG_BMSR);
000200  2001              MOVS     r0,#1
000202  f7fffffe          BL       read_PHY
000206  4604              MOV      r4,r0
;;;245    		if (regv & (1 << 2)) 
000208  f0040004          AND      r0,r4,#4
00020c  2800              CMP      r0,#0
00020e  d020              BEQ      |L4.594|
;;;246    		{
;;;247    			printf_eth("4. Connection Succeeded\r\n");
000210  a077              ADR      r0,|L4.1008|
000212  f7fffffe          BL       __2printf
;;;248    			
;;;249    			/* PHY已经连接上网络 */ 
;;;250    			g_ucEthLinkStatus = 1;
000216  2001              MOVS     r0,#1
000218  497c              LDR      r1,|L4.1036|
00021a  7008              STRB     r0,[r1,#0]
;;;251    			
;;;252    			/* 获取连接信息 */
;;;253    			regv = read_PHY (PHY_REG_DSCSR);
00021c  2011              MOVS     r0,#0x11
00021e  f7fffffe          BL       read_PHY
000222  4604              MOV      r4,r0
;;;254    			
;;;255    			if ((regv & (1 << 15))|(regv & (1 << 13))) 
000224  f4044000          AND      r0,r4,#0x8000
000228  f4045100          AND      r1,r4,#0x2000
00022c  4308              ORRS     r0,r0,r1
00022e  b120              CBZ      r0,|L4.570|
;;;256    			{
;;;257    				/* 全双工 */
;;;258    				printf_eth("5. Full-duplex connection\r\n");
000230  a077              ADR      r0,|L4.1040|
000232  f7fffffe          BL       __2printf
;;;259    				conn |= PHY_CON_SET_FULLD;
000236  f0460602          ORR      r6,r6,#2
                  |L4.570|
;;;260    			}
;;;261    			
;;;262    			if ((regv & (1 << 15))|(regv & (1 << 14))) 
00023a  f4044000          AND      r0,r4,#0x8000
00023e  f4044180          AND      r1,r4,#0x4000
000242  4308              ORRS     r0,r0,r1
000244  b120              CBZ      r0,|L4.592|
;;;263    			{
;;;264    				/* 速度100Mbps的网络 */
;;;265    				printf_eth("6. 100Mbps Mode\r\n");
000246  a079              ADR      r0,|L4.1068|
000248  f7fffffe          BL       __2printf
;;;266    				conn |= PHY_CON_SET_100M;
00024c  f0460601          ORR      r6,r6,#1
                  |L4.592|
;;;267    			}
;;;268    			break;
000250  e009              B        |L4.614|
                  |L4.594|
;;;269    		}
;;;270    		else
;;;271    		{
;;;272    			printf_eth("4. Connection failed\r\n");
000252  a07b              ADR      r0,|L4.1088|
000254  f7fffffe          BL       __2printf
;;;273    			
;;;274    			/* 未连接上 */ 
;;;275    			g_ucEthLinkStatus = 0;
000258  2000              MOVS     r0,#0
00025a  496c              LDR      r1,|L4.1036|
00025c  7008              STRB     r0,[r1,#0]
00025e  1c6d              ADDS     r5,r5,#1              ;242
                  |L4.608|
000260  f5b53f80          CMP      r5,#0x10000           ;242
000264  d3cc              BCC      |L4.512|
                  |L4.614|
000266  bf00              NOP                            ;268
;;;276    		}
;;;277    	}
;;;278    
;;;279    	/* 第4步：使能DM9161/9162中断 ***********************************************************/
;;;280    	/* 使能DM9161/9162的连接中断 */
;;;281    	write_PHY (PHY_REG_INTERRUPT, 1<<12);
000268  f44f5180          MOV      r1,#0x1000
00026c  2015              MOVS     r0,#0x15
00026e  f7fffffe          BL       write_PHY
;;;282    
;;;283    	/* 配置引脚PH6来接收中断信号 */
;;;284    	Eth_Link_EXTIConfig();
000272  f7fffffe          BL       Eth_Link_EXTIConfig
;;;285    
;;;286    	/* 第5步：使能DM9161/9162中断 ***********************************************************/	
;;;287    	/* 
;;;288    	   初始化MAC配置寄存器
;;;289    	   （1）当该位MCR_ROD置1时，MAC禁止在半双工模式下接收帧。
;;;290    	   （2）当该位MCR_ROD清0时，MAC接收PHY发送的所有数据包。
;;;291    	   （3）如果MAC在全双工模式下工作，该位不适用。
;;;292    	*/
;;;293    	ETH->MACCR  = MCR_ROD;
000276  f44f5000          MOV      r0,#0x2000
00027a  493c              LDR      r1,|L4.876|
00027c  6008              STR      r0,[r1,#0]
;;;294    
;;;295    	/* 设置MAC工作在全双工模式 */
;;;296    	if (conn & PHY_CON_SET_FULLD) 
00027e  f0060002          AND      r0,r6,#2
000282  b120              CBZ      r0,|L4.654|
;;;297    	{
;;;298    		/* 使能全双工 */
;;;299    		ETH->MACCR |= MCR_DM;
000284  4608              MOV      r0,r1
000286  6800              LDR      r0,[r0,#0]
000288  f4406000          ORR      r0,r0,#0x800
00028c  6008              STR      r0,[r1,#0]
                  |L4.654|
;;;300    	}
;;;301    
;;;302    	/* 
;;;303    		通过位MCR_FES配置MAC通信速度
;;;304    		（1）0表示10Mbps
;;;305    		（2）1表示100Mbps
;;;306    	*/
;;;307    	if (conn & PHY_CON_SET_100M) 
00028e  f0060001          AND      r0,r6,#1
000292  b128              CBZ      r0,|L4.672|
;;;308    	{
;;;309    		/* 配置为100Mbps */
;;;310    		ETH->MACCR |= MCR_FES;
000294  4835              LDR      r0,|L4.876|
000296  6800              LDR      r0,[r0,#0]
000298  f4404080          ORR      r0,r0,#0x4000
00029c  4933              LDR      r1,|L4.876|
00029e  6008              STR      r0,[r1,#0]
                  |L4.672|
;;;311    	}
;;;312    
;;;313    	/* MACFFR 以太网帧过滤寄存器，配置可接收所有MAC组播包，即MAC地址第一个字节的bit0 = 1 */
;;;314    	ETH->MACFFR = MFFR_HPF | MFFR_PAM;
0002a0  f44f6082          MOV      r0,#0x410
0002a4  4931              LDR      r1,|L4.876|
0002a6  6048              STR      r0,[r1,#4]
;;;315    	
;;;316    	/* MACFCR 以太网流控制寄存器，ZQPD零时间片暂停禁止 */
;;;317    	ETH->MACFCR = MFCR_ZQPD;
0002a8  2080              MOVS     r0,#0x80
0002aa  6188              STR      r0,[r1,#0x18]
;;;318    
;;;319    	/* 设置以太网MAC地址寄存器 */
;;;320    	ETH->MACA0HR = ((U32)own_hw_adr[5] <<  8) | (U32)own_hw_adr[4];
0002ac  486a              LDR      r0,|L4.1112|
0002ae  7900              LDRB     r0,[r0,#4]  ; own_hw_adr
0002b0  4969              LDR      r1,|L4.1112|
0002b2  7949              LDRB     r1,[r1,#5]  ; own_hw_adr
0002b4  ea402001          ORR      r0,r0,r1,LSL #8
0002b8  492c              LDR      r1,|L4.876|
0002ba  6408              STR      r0,[r1,#0x40]
;;;321    	ETH->MACA0LR = ((U32)own_hw_adr[3] << 24) | (U32)own_hw_adr[2] << 16 |
0002bc  4866              LDR      r0,|L4.1112|
0002be  78c0              LDRB     r0,[r0,#3]  ; own_hw_adr
0002c0  0600              LSLS     r0,r0,#24
0002c2  4965              LDR      r1,|L4.1112|
0002c4  7889              LDRB     r1,[r1,#2]  ; own_hw_adr
0002c6  ea404001          ORR      r0,r0,r1,LSL #16
0002ca  4963              LDR      r1,|L4.1112|
0002cc  7849              LDRB     r1,[r1,#1]  ; own_hw_adr
0002ce  ea402001          ORR      r0,r0,r1,LSL #8
0002d2  4961              LDR      r1,|L4.1112|
0002d4  7809              LDRB     r1,[r1,#0]  ; own_hw_adr
0002d6  4308              ORRS     r0,r0,r1
0002d8  4924              LDR      r1,|L4.876|
0002da  6448              STR      r0,[r1,#0x44]
;;;322    				   ((U32)own_hw_adr[1] <<  8) | (U32)own_hw_adr[0];
;;;323    
;;;324    	/* 初始化DMA发送和接收描述符 */
;;;325    	rx_descr_init ();
0002dc  f7fffffe          BL       rx_descr_init
;;;326    	tx_descr_init ();
0002e0  f7fffffe          BL       tx_descr_init
;;;327    
;;;328    	/* 
;;;329    	    刷新FIFO，启动DMA发送和接收功能
;;;330    		DMAOMR 工作模式寄存器
;;;331    		位20 DOMR_FTF：刷新发送 FIFO (Flush transmit FIFO)：
;;;332    		               该位置1时，发送FIFO控制器逻辑会复位为默认值，因此，TX FIFO中的所有数据均会
;;;333    			           丢失/刷新。刷新操作结束时该位在内部清零。此位清零之前不得对工作模式寄存器执
;;;334    			           行写操作。
;;;335    		位13 DOMR_ST：启动/停止发送 (Start/stop transmission)
;;;336    		              该位置1时，启动发送，DMA会检查当前位置的发送列表来查找待发送的帧。
;;;337    		位1  DOMR_SR：启动/停止接收 (Start/stop receive)
;;;338    		              该位置1时，启动接收，DMA尝试从接收列表中获取描述符并处理传入帧。
;;;339    	*/
;;;340    	ETH->DMAOMR = DOMR_FTF | DOMR_ST | DOMR_SR;
0002e4  485d              LDR      r0,|L4.1116|
0002e6  4920              LDR      r1,|L4.872|
0002e8  6188              STR      r0,[r1,#0x18]
;;;341    
;;;342    	/* 使能发送和接收 */
;;;343    	ETH->MACCR |= MCR_TE | MCR_RE;
0002ea  4820              LDR      r0,|L4.876|
0002ec  6800              LDR      r0,[r0,#0]
0002ee  f040000c          ORR      r0,r0,#0xc
0002f2  491e              LDR      r1,|L4.876|
0002f4  6008              STR      r0,[r1,#0]
;;;344    
;;;345    	/* 复位所有MAC中断 */
;;;346    	ETH->DMASR  = 0xFFFFFFFF;
0002f6  f04f30ff          MOV      r0,#0xffffffff
0002fa  491b              LDR      r1,|L4.872|
0002fc  6148              STR      r0,[r1,#0x14]
;;;347    
;;;348    	/*  
;;;349    	    使能发送和接收中断
;;;350    		DMAIER 中断使能寄存器
;;;351    		位16 NISE：使能所有正常中断(Normal interrupt summary enable)
;;;352    		位15 AISE：使能所有异常中断(Abnormal interrupt summary enable)
;;;353    		位7 RBUIE：接收缓冲区不可用中断使能(Receive buffer unavailable interrupt enable)
;;;354    		           当该位和AISE位都置1后，可使能接收缓冲区不可用中断。该位清零时，会禁止接
;;;355    				   收缓冲区不可用中断。
;;;356    		位6   RIE：接收中断使能 (Receive interrupt enable)
;;;357    		           当该位和AISE都置1后，可使能接收中断。该位清零时，会禁止接收中断。
;;;358    	*/
;;;359    	ETH->DMAIER = ETH_DMAIER_NISE | ETH_DMAIER_AISE | ETH_DMAIER_RBUIE | ETH_DMAIER_RIE;
0002fe  4858              LDR      r0,|L4.1120|
000300  61c8              STR      r0,[r1,#0x1c]
;;;360    
;;;361    	/* 设置为最高优先级，仅调用NVIC->ISER设置的默认优先级也是最高优先级0 */
;;;362    	NVIC_SetPriority(ETH_IRQn, 0);
000302  203d              MOVS     r0,#0x3d
000304  2100              MOVS     r1,#0
000306  2800              CMP      r0,#0
000308  da07              BGE      |L4.794|
00030a  070a              LSLS     r2,r1,#28
00030c  0e17              LSRS     r7,r2,#24
00030e  4a55              LDR      r2,|L4.1124|
000310  f000030f          AND      r3,r0,#0xf
000314  1f1b              SUBS     r3,r3,#4
000316  54d7              STRB     r7,[r2,r3]
000318  e003              B        |L4.802|
                  |L4.794|
00031a  070a              LSLS     r2,r1,#28
00031c  0e13              LSRS     r3,r2,#24
00031e  4a52              LDR      r2,|L4.1128|
000320  5413              STRB     r3,[r2,r0]
                  |L4.802|
000322  bf00              NOP      
;;;363    	
;;;364    	printf_eth("===============================================================\r\n");
000324  4812              LDR      r0,|L4.880|
000326  f7fffffe          BL       __2printf
;;;365    }
00032a  e8bd81f0          POP      {r4-r8,pc}
;;;366    
                          ENDP

00032e  0000              DCW      0x0000
                  |L4.816|
                          DCD      0xe000e180
                  |L4.820|
                          DCD      0x40023844
                  |L4.824|
                          DCD      0x40013804
                  |L4.828|
                          DCD      0x1e000047
                  |L4.832|
                          DCD      0x40020000
                  |L4.836|
                          DCD      0x0003c03c
                  |L4.840|
                          DCD      0x0ffff00f
                  |L4.844|
                          DCD      0xb0000bb0
                  |L4.848|
                          DCD      0x40020800
                  |L4.852|
                          DCD      0xff00ff0f
                  |L4.856|
                          DCD      0x00bb00b0
                  |L4.860|
                          DCD      0x40021800
                  |L4.864|
                          DCD      0xf00f0fff
                  |L4.868|
                          DCD      0x0bb0b000
                  |L4.872|
                          DCD      0x40029000
                  |L4.876|
                          DCD      0x40028000
                  |L4.880|
                          DCD      ||.conststring||
                  |L4.884|
000374  cfc2c3e6          DCB      207,194,195,230,202,199,"DM9161/9162",181,196,211,178,188
000378  cac7444d
00037c  39313631
000380  2f393136
000384  32b5c4d3
000388  b2bc    
00038a  feb3f5ca          DCB      254,179,245,202,188,187,175,163,186,"\r\n",0
00038e  bcbbafa3
000392  ba0d0a00
000396  00                DCB      0
000397  00                DCB      0
                  |L4.920|
000398  312e2053          DCB      "1. Start PHY_ID_DM9161/9162 Init\r\n",0
00039c  74617274
0003a0  20504859
0003a4  5f49445f
0003a8  444d3931
0003ac  36312f39
0003b0  31363220
0003b4  496e6974
0003b8  0d0a00  
0003bb  00                DCB      0
                  |L4.956|
0003bc  322e2052          DCB      "2. Reset Complete\r\n",0
0003c0  65736574
0003c4  20436f6d
0003c8  706c6574
0003cc  650d0a00
                  |L4.976|
0003d0  332e2041          DCB      "3. Auto-Negotiation Complete\r\n",0
0003d4  75746f2d
0003d8  4e65676f
0003dc  74696174
0003e0  696f6e20
0003e4  436f6d70
0003e8  6c657465
0003ec  0d0a00  
0003ef  00                DCB      0
                  |L4.1008|
0003f0  342e2043          DCB      "4. Connection Succeeded\r\n",0
0003f4  6f6e6e65
0003f8  6374696f
0003fc  6e205375
000400  63636565
000404  6465640d
000408  0a00    
00040a  00                DCB      0
00040b  00                DCB      0
                  |L4.1036|
                          DCD      g_ucEthLinkStatus
                  |L4.1040|
000410  352e2046          DCB      "5. Full-duplex connection\r\n",0
000414  756c6c2d
000418  6475706c
00041c  65782063
000420  6f6e6e65
000424  6374696f
000428  6e0d0a00
                  |L4.1068|
00042c  362e2031          DCB      "6. 100Mbps Mode\r\n",0
000430  30304d62
000434  7073204d
000438  6f64650d
00043c  0a00    
00043e  00                DCB      0
00043f  00                DCB      0
                  |L4.1088|
000440  342e2043          DCB      "4. Connection failed\r\n",0
000444  6f6e6e65
000448  6374696f
00044c  6e206661
000450  696c6564
000454  0d0a00  
000457  00                DCB      0
                  |L4.1112|
                          DCD      own_hw_adr
                  |L4.1116|
                          DCD      0x00102002
                  |L4.1120|
                          DCD      0x000180c0
                  |L4.1124|
                          DCD      0xe000ed18
                  |L4.1128|
                          DCD      0xe000e400

                          AREA ||i.int_disable_eth||, CODE, READONLY, ALIGN=2

                  int_disable_eth PROC
;;;387    */
;;;388    void int_disable_eth (void) 
000000  f04f5100          MOV      r1,#0x20000000
;;;389    {
;;;390    	NVIC->ICER[1] = 1 << 29;
000004  4801              LDR      r0,|L5.12|
000006  6001              STR      r1,[r0,#0]
;;;391    }
000008  4770              BX       lr
;;;392    
                          ENDP

00000a  0000              DCW      0x0000
                  |L5.12|
                          DCD      0xe000e184

                          AREA ||i.int_enable_eth||, CODE, READONLY, ALIGN=2

                  int_enable_eth PROC
;;;374    */
;;;375    void int_enable_eth (void) 
000000  f04f5000          MOV      r0,#0x20000000
;;;376    {
;;;377    	NVIC->ISER[1] = 1 << 29;
000004  4901              LDR      r1,|L6.12|
000006  6008              STR      r0,[r1,#0]
;;;378    }
000008  4770              BX       lr
;;;379    
                          ENDP

00000a  0000              DCW      0x0000
                  |L6.12|
                          DCD      0xe000e104

                          AREA ||i.read_PHY||, CODE, READONLY, ALIGN=2

                  read_PHY PROC
;;;721    */
;;;722    static U16 read_PHY (U32 PhyReg) 
000000  4601              MOV      r1,r0
;;;723    {
;;;724    	U32 tout;
;;;725    
;;;726    	/*
;;;727    	   MACMIIAR 以太网MAC MII 地址寄存器
;;;728           位 15:11 PA：PHY 地址 (PHY address)，对应这里的PHY_DEF_ADDR
;;;729    					该字段指示正在访问32个可能的PHY器件中的哪一个。	
;;;730    	   
;;;731    	   位 10:6  MR：MII寄存器 (MII register)，对应这里的PhyReg
;;;732    					这些位在所选的PHY器件中选择要访问的MII寄存器。
;;;733    	   位 1     MW：MII写(MII write)，对应这里的MMAR_MW
;;;734    	                此位置1是在告知PHY，将要启动一个使用MII数据寄存器的写操作。
;;;735    	                如果此位未置，则表示会启动一个读操作，将数据放入MII数据寄存器。
;;;736    	   位 0     MB：MII忙碌 (MII busy)，对应这里的MMAR_MB
;;;737    	                向ETH_MACMIIAR和ETH_MACMIIDR写入前，此位应读取逻辑0。向ETH_MACMIIAR写入过程中，此
;;;738    	                位也必须复位为0。在PHY寄存器访问过程中，此位由应用程序置1，指示读或写访问正在进行中。
;;;739    	                在对PHY进行写操作过程中，ETH_MACMIIDR（MII数据）应始终保持有效，直到MAC将此位清零。
;;;740    	                在对PHY进行读操作过程中，ETH_MACMIIDR始终无效，直到MAC将此位清零。在此位清零后，才
;;;741    					可以向ETH_MACMIIAR（MII地址）写入。
;;;742    	*/
;;;743    	ETH->MACMIIAR = PHY_DEF_ADDR << 11 | PhyReg << 6 | MMAR_MB;
000002  f44f6000          MOV      r0,#0x800
000006  ea401081          ORR      r0,r0,r1,LSL #6
00000a  1c40              ADDS     r0,r0,#1
00000c  4b09              LDR      r3,|L7.52|
00000e  6118              STR      r0,[r3,#0x10]
;;;744    
;;;745    	/* 等待操作完成，即等待MMAR_MB位被清零 */
;;;746    	tout = 0;
000010  2200              MOVS     r2,#0
;;;747    	for (tout = 0; tout < MII_RD_TOUT; tout++) 
000012  bf00              NOP      
000014  e006              B        |L7.36|
                  |L7.22|
;;;748    	{
;;;749    		if ((ETH->MACMIIAR & MMAR_MB) == 0) 
000016  4807              LDR      r0,|L7.52|
000018  6900              LDR      r0,[r0,#0x10]
00001a  f0000001          AND      r0,r0,#1
00001e  b900              CBNZ     r0,|L7.34|
;;;750    		{
;;;751    			break;
000020  e003              B        |L7.42|
                  |L7.34|
000022  1c52              ADDS     r2,r2,#1              ;747
                  |L7.36|
000024  f5b22fa0          CMP      r2,#0x50000           ;747
000028  d3f5              BCC      |L7.22|
                  |L7.42|
00002a  bf00              NOP      
;;;752    		}
;;;753    	}
;;;754    	
;;;755    	/* 从 PHY 中读取16bit的数据值 */
;;;756    	return (ETH->MACMIIDR & MMDR_MD);
00002c  4801              LDR      r0,|L7.52|
00002e  6940              LDR      r0,[r0,#0x14]
000030  b280              UXTH     r0,r0
;;;757    }
000032  4770              BX       lr
;;;758    
                          ENDP

                  |L7.52|
                          DCD      0x40028000

                          AREA ||i.rx_descr_init||, CODE, READONLY, ALIGN=2

                  rx_descr_init PROC
;;;574    */
;;;575    static void rx_descr_init (void) 
000000  2200              MOVS     r2,#0
;;;576    {
;;;577    	U32 i,next;
;;;578    
;;;579    	/*
;;;580    	   1. RDES0：接收描述符字0，对应Rx_Desc[i].Stat
;;;581    	      位31 OWN：所有关系位 (Own bit)
;;;582    					该位置1时，指示描述符由MAC子系统的DMA所拥有。
;;;583    	                该位清零时，指示描述符由主机所拥有，即CPU。
;;;584    	                DMA在帧接收完成或此描述符的关联缓冲区已满时将该位清零。
;;;585    	
;;;586    	   2. RDES1：接收描述符字1，对应Rx_Desc[i].Ctrl
;;;587    	      位14   RCH： 链接的第二个地址 (Second address chained)
;;;588    					   该位置1时，表示描述符中的第二个地址是下一个描述符地址，而非第二个缓冲区地址。该
;;;589                           位置1时，RBS2(RDES1[28:16])为无关值。RDES1[15]比RDES1[14]优先处理。
;;;590    	      位12:0 RBS1：接收缓冲区1大小 (Receive buffer 1 size)
;;;591                           第一个数据缓冲区的大小以字节为单位。即使RDES2（缓冲区1地址指针）的值未对齐，缓
;;;592    	                   冲区大小也必须为4、8或16的倍数，具体取决于总线宽度32、64或128。如果缓冲区大小不
;;;593    	                   是4、8或16的倍数，这种情况的结果是未定义。如果该字段为0，则DMA会忽略该缓冲区并
;;;594    	                   使用缓冲区2或下一个描述符，具体取决于RCH（位14）的值。
;;;595    	
;;;596    	   3. RDES2：接收描述符字2，对应Rx_Desc[i].Addr
;;;597    	      位31:0 RBAP1/RTSL：接收缓冲区1地址指针/接收帧时间戳低位
;;;598    		                     Receive buffer 1 address pointer
;;;599                                 Receive frame time stamp low
;;;600    	
;;;601    	   4. RDES3：接收描述符字3，对应Rx_Desc[i].Next
;;;602    	      位31:0 RBAP2/RTSH：接收缓冲区2地址指针（下一个描述符地址）/ 接收帧时间戳高位
;;;603    		                     Receive buffer 2 address pointer (next descriptor address) 
;;;604    		                     Receive frame time stamp high
;;;605    	*/
;;;606    	RxBufIndex = 0;
000002  4b16              LDR      r3,|L8.92|
000004  701a              STRB     r2,[r3,#0]
;;;607    	
;;;608    	for (i = 0, next = 0; i < NUM_RX_BUF; i++) 
000006  2000              MOVS     r0,#0
000008  2100              MOVS     r1,#0
00000a  e021              B        |L8.80|
                  |L8.12|
;;;609    	{
;;;610    		if (++next == NUM_RX_BUF) next = 0;
00000c  1c4a              ADDS     r2,r1,#1
00000e  4611              MOV      r1,r2
000010  2a04              CMP      r2,#4
000012  d100              BNE      |L8.22|
000014  2100              MOVS     r1,#0
                  |L8.22|
;;;611    		Rx_Desc[i].Stat = DMA_RX_OWN;
000016  f04f4200          MOV      r2,#0x80000000
00001a  4b11              LDR      r3,|L8.96|
00001c  eb031300          ADD      r3,r3,r0,LSL #4
000020  601a              STR      r2,[r3,#0]
;;;612    		Rx_Desc[i].Ctrl = DMA_RX_RCH | ETH_BUF_SIZE;
000022  f44f428c          MOV      r2,#0x4600
000026  4b0e              LDR      r3,|L8.96|
000028  eb031300          ADD      r3,r3,r0,LSL #4
00002c  605a              STR      r2,[r3,#4]
;;;613    		Rx_Desc[i].Addr = (U32)&rx_buf[i];
00002e  eb000240          ADD      r2,r0,r0,LSL #1
000032  4b0c              LDR      r3,|L8.100|
000034  eb032242          ADD      r2,r3,r2,LSL #9
000038  4b09              LDR      r3,|L8.96|
00003a  eb031300          ADD      r3,r3,r0,LSL #4
00003e  609a              STR      r2,[r3,#8]
;;;614    		Rx_Desc[i].Next = (U32)&Rx_Desc[next];
000040  4a07              LDR      r2,|L8.96|
000042  eb021201          ADD      r2,r2,r1,LSL #4
000046  4b06              LDR      r3,|L8.96|
000048  eb031300          ADD      r3,r3,r0,LSL #4
00004c  60da              STR      r2,[r3,#0xc]
00004e  1c40              ADDS     r0,r0,#1              ;608
                  |L8.80|
000050  2804              CMP      r0,#4                 ;608
000052  d3db              BCC      |L8.12|
;;;615    	}
;;;616    	
;;;617    	/* 接收描述符列表地址寄存器指向接收描述符列表的起始处 */
;;;618    	ETH->DMARDLAR = (U32)&Rx_Desc[0];
000054  4a02              LDR      r2,|L8.96|
000056  4b04              LDR      r3,|L8.104|
000058  60da              STR      r2,[r3,#0xc]
;;;619    }
00005a  4770              BX       lr
;;;620    
                          ENDP

                  |L8.92|
                          DCD      RxBufIndex
                  |L8.96|
                          DCD      Rx_Desc
                  |L8.100|
                          DCD      rx_buf
                  |L8.104|
                          DCD      0x40029000

                          AREA ||i.send_frame||, CODE, READONLY, ALIGN=2

                  send_frame PROC
;;;400    */
;;;401    void send_frame (OS_FRAME *frame) 
000000  b570              PUSH     {r4-r6,lr}
;;;402    {
000002  4601              MOV      r1,r0
;;;403    	U32 *sp,*dp;
;;;404    	U32 i,j;
;;;405    
;;;406    	j = TxBufIndex;
000004  4d1b              LDR      r5,|L9.116|
000006  7828              LDRB     r0,[r5,#0]  ; TxBufIndex
;;;407    	
;;;408    	/* 等待上一帧数据发送完成 */
;;;409    	while (Tx_Desc[j].CtrlStat & DMA_TX_OWN);
000008  bf00              NOP      
                  |L9.10|
00000a  4d1b              LDR      r5,|L9.120|
00000c  eb051500          ADD      r5,r5,r0,LSL #4
000010  682d              LDR      r5,[r5,#0]
000012  f0054500          AND      r5,r5,#0x80000000
000016  2d00              CMP      r5,#0
000018  d1f7              BNE      |L9.10|
;;;410    
;;;411    	sp = (U32 *)&frame->data[0];
00001a  1d0a              ADDS     r2,r1,#4
;;;412    	dp = (U32 *)(Tx_Desc[j].Addr & ~3);
00001c  4d16              LDR      r5,|L9.120|
00001e  eb051500          ADD      r5,r5,r0,LSL #4
000022  68ad              LDR      r5,[r5,#8]
000024  f0250303          BIC      r3,r5,#3
;;;413    
;;;414    	/* 复制要发送的数据到DMA发送描述符中 */
;;;415    	for (i = (frame->length + 3) >> 2; i; i--) 
000028  880d              LDRH     r5,[r1,#0]
00002a  1ced              ADDS     r5,r5,#3
00002c  10ac              ASRS     r4,r5,#2
00002e  e002              B        |L9.54|
                  |L9.48|
;;;416    	{
;;;417    		*dp++ = *sp++;
000030  ca20              LDM      r2!,{r5}
000032  c320              STM      r3!,{r5}
000034  1e64              SUBS     r4,r4,#1              ;415
                  |L9.54|
000036  2c00              CMP      r4,#0                 ;415
000038  d1fa              BNE      |L9.48|
;;;418    	}
;;;419    	
;;;420    	/* 设置数据帧大小 */
;;;421    	Tx_Desc[j].Size      = frame->length;
00003a  880d              LDRH     r5,[r1,#0]
00003c  4e0e              LDR      r6,|L9.120|
00003e  eb061600          ADD      r6,r6,r0,LSL #4
000042  6075              STR      r5,[r6,#4]
;;;422    	
;;;423    	/* 发送描述符由DMA控制发送 */
;;;424    	Tx_Desc[j].CtrlStat |= DMA_TX_OWN;
000044  4d0c              LDR      r5,|L9.120|
000046  eb051500          ADD      r5,r5,r0,LSL #4
00004a  682d              LDR      r5,[r5,#0]
00004c  f0454500          ORR      r5,r5,#0x80000000
000050  4e09              LDR      r6,|L9.120|
000052  eb061600          ADD      r6,r6,r0,LSL #4
000056  6035              STR      r5,[r6,#0]
;;;425    	
;;;426    	if (++j == NUM_TX_BUF) j = 0;
000058  1c45              ADDS     r5,r0,#1
00005a  4628              MOV      r0,r5
00005c  2d02              CMP      r5,#2
00005e  d100              BNE      |L9.98|
000060  2000              MOVS     r0,#0
                  |L9.98|
;;;427    	TxBufIndex = j;
000062  4e04              LDR      r6,|L9.116|
000064  7030              STRB     r0,[r6,#0]
;;;428    	
;;;429    	/* 开始帧传输 */
;;;430    	/* 
;;;431    	   DMASR 以太网 DMA 状态寄存器
;;;432    	   向ETH_DMASR寄存器[16:0]中的（未保留）位写入1会将其清零，写入 0 则不起作用。
;;;433    	   位1 TPSS：发送过程停止状态 (Transmit process stopped status)
;;;434                     当发送停止时，此位置 1。
;;;435    	*/
;;;436    	ETH->DMASR   = DSR_TPSS;
000066  2502              MOVS     r5,#2
000068  4e04              LDR      r6,|L9.124|
00006a  6175              STR      r5,[r6,#0x14]
;;;437    	
;;;438    	/*
;;;439    	   DMATPDR 以太网DMA发送轮询请求寄存器
;;;440           应用程序使用此寄存器来指示DMA轮询发送描述符列表。
;;;441           位 31:0 TPD：发送轮询请求(Transmit poll demand)
;;;442                        向这些位写入任何值时，DMA都会读取ETH_DMACHTDR寄存器指向的当前描述符。如果
;;;443                        该描述符不可用（由CPU所有），则发送会返回到挂起状态，并将ETH_DMASR寄存器位2
;;;444                        进行置位。如果该描述符可用，则发送会继续进行。	   
;;;445    	*/
;;;446    	ETH->DMATPDR = 0;
00006c  2500              MOVS     r5,#0
00006e  6075              STR      r5,[r6,#4]
;;;447    }
000070  bd70              POP      {r4-r6,pc}
;;;448    
                          ENDP

000072  0000              DCW      0x0000
                  |L9.116|
                          DCD      TxBufIndex
                  |L9.120|
                          DCD      Tx_Desc
                  |L9.124|
                          DCD      0x40029000

                          AREA ||i.tx_descr_init||, CODE, READONLY, ALIGN=2

                  tx_descr_init PROC
;;;628    */
;;;629    static void tx_descr_init (void) 
000000  2200              MOVS     r2,#0
;;;630    {
;;;631    	U32 i,next;
;;;632    
;;;633    	/*
;;;634    	   1. TDES0：发送描述符字0，对应Tx_Desc[i].CtrlStat
;;;635    	      位29 LS ：末段 (Last segment)
;;;636                        该位置1时，指示缓冲区中包含帧的末段。
;;;637    	      位28 FS ：首段 (First segment)
;;;638                        该位置1时，指示缓冲区中包含帧的首段
;;;639              位20 TCH：链接的第二个地址 (Second address chained)
;;;640                        该位置1时，表示描述符中的第二个地址是下一个描述符地址，而非第二个缓冲区地址。
;;;641                        TDES0[20]置1时，TBS2(TDES1[28:16])为无关值。TDES0[21]比TDES0[20]优先处理。
;;;642    	
;;;643    	   2. TDES1：发送描述符字1，对应Tx_Desc[i].Size
;;;644    	
;;;645    	   3. TDES2：发送描述符字2，对应Tx_Desc[i].Addr
;;;646    	      位31:0 TBAP1：发送缓冲区1地址指针/发送帧时间戳低位 
;;;647    	                    Transmit buffer 1 address pointer / Transmitframe time stamp low
;;;648    	
;;;649    	   4. TDES3：发送描述符字3，对应Tx_Desc[i].Next
;;;650    	      位 1:0 TBAP2：发送缓冲区2地址指针（下一个描述符地址）/ 发送帧时间戳高位
;;;651         		            Transmit buffer 2 address pointer (Next descriptor address) 
;;;652    						Transmit frame time stamp high
;;;653    	*/
;;;654    	TxBufIndex = 0;
000002  4b13              LDR      r3,|L10.80|
000004  701a              STRB     r2,[r3,#0]
;;;655    	for (i = 0, next = 0; i < NUM_TX_BUF; i++) 
000006  2000              MOVS     r0,#0
000008  2100              MOVS     r1,#0
00000a  e01a              B        |L10.66|
                  |L10.12|
;;;656    	{
;;;657    		if (++next == NUM_TX_BUF) next = 0;
00000c  1c4a              ADDS     r2,r1,#1
00000e  4611              MOV      r1,r2
000010  2a02              CMP      r2,#2
000012  d100              BNE      |L10.22|
000014  2100              MOVS     r1,#0
                  |L10.22|
;;;658    		Tx_Desc[i].CtrlStat = DMA_TX_TCH | DMA_TX_LS | DMA_TX_FS;
000016  4a0f              LDR      r2,|L10.84|
000018  4b0f              LDR      r3,|L10.88|
00001a  eb031300          ADD      r3,r3,r0,LSL #4
00001e  601a              STR      r2,[r3,#0]
;;;659    		Tx_Desc[i].Addr     = (U32)&tx_buf[i];
000020  eb000240          ADD      r2,r0,r0,LSL #1
000024  4b0d              LDR      r3,|L10.92|
000026  eb032242          ADD      r2,r3,r2,LSL #9
00002a  4b0b              LDR      r3,|L10.88|
00002c  eb031300          ADD      r3,r3,r0,LSL #4
000030  609a              STR      r2,[r3,#8]
;;;660    		Tx_Desc[i].Next     = (U32)&Tx_Desc[next];
000032  4a09              LDR      r2,|L10.88|
000034  eb021201          ADD      r2,r2,r1,LSL #4
000038  4b07              LDR      r3,|L10.88|
00003a  eb031300          ADD      r3,r3,r0,LSL #4
00003e  60da              STR      r2,[r3,#0xc]
000040  1c40              ADDS     r0,r0,#1              ;655
                  |L10.66|
000042  2802              CMP      r0,#2                 ;655
000044  d3e2              BCC      |L10.12|
;;;661    	}
;;;662    	
;;;663    	/* 发送描述符列表地址寄存器指向发送描述符列表的起始处 */
;;;664    	ETH->DMATDLAR = (U32)&Tx_Desc[0];
000046  4a04              LDR      r2,|L10.88|
000048  4b05              LDR      r3,|L10.96|
00004a  611a              STR      r2,[r3,#0x10]
;;;665    }
00004c  4770              BX       lr
;;;666    
                          ENDP

00004e  0000              DCW      0x0000
                  |L10.80|
                          DCD      TxBufIndex
                  |L10.84|
                          DCD      0x30100000
                  |L10.88|
                          DCD      Tx_Desc
                  |L10.92|
                          DCD      tx_buf
                  |L10.96|
                          DCD      0x40029000

                          AREA ||i.write_PHY||, CODE, READONLY, ALIGN=2

                  write_PHY PROC
;;;676    */
;;;677    static void write_PHY (U32 PhyReg, U16 Value)
000000  b510              PUSH     {r4,lr}
;;;678    {
;;;679    	U32 tout;
;;;680    
;;;681    	/* 数据寄存器，存入要写入PHY的16位数据 */
;;;682    	ETH->MACMIIDR = Value;
000002  4b0b              LDR      r3,|L11.48|
000004  6159              STR      r1,[r3,#0x14]
;;;683    
;;;684    	/*
;;;685    	   MACMIIAR 以太网MAC MII 地址寄存器
;;;686           位 15:11 PA：PHY 地址 (PHY address)，对应这里的PHY_DEF_ADDR
;;;687    					该字段指示正在访问32个可能的PHY器件中的哪一个。	
;;;688    	   
;;;689    	   位 10:6  MR：MII寄存器 (MII register)，对应这里的PhyReg
;;;690    					这些位在所选的PHY器件中选择要访问的MII寄存器。
;;;691    	   位 1     MW：MII写(MII write)，对应这里的MMAR_MW
;;;692    	                此位置1是在告知PHY，将要启动一个使用MII数据寄存器的写操作。
;;;693    	                如果此位未置，则表示会启动一个读操作，将数据放入MII数据寄存器。
;;;694    	   位 0     MB：MII忙碌 (MII busy)，对应这里的MMAR_MB
;;;695    	                向ETH_MACMIIAR和ETH_MACMIIDR写入前，此位应读取逻辑0。向ETH_MACMIIAR写入过程中，此
;;;696    	                位也必须复位为0。在PHY寄存器访问过程中，此位由应用程序置1，指示读或写访问正在进行中。
;;;697    	                在对PHY进行写操作过程中，ETH_MACMIIDR（MII数据）应始终保持有效，直到MAC将此位清零。
;;;698    	                在对PHY进行读操作过程中，ETH_MACMIIDR始终无效，直到MAC将此位清零。在此位清零后，才
;;;699    					可以向ETH_MACMIIAR（MII地址）写入。
;;;700    	*/
;;;701    	ETH->MACMIIAR = PHY_DEF_ADDR << 11 | PhyReg << 6 | MMAR_MW | MMAR_MB;
000006  14db              ASRS     r3,r3,#19
000008  ea431380          ORR      r3,r3,r0,LSL #6
00000c  1cdb              ADDS     r3,r3,#3
00000e  4c08              LDR      r4,|L11.48|
000010  6123              STR      r3,[r4,#0x10]
;;;702    
;;;703    	/* 等待操作完成，即等待MMAR_MB位被清零 */
;;;704    	tout = 0;
000012  2200              MOVS     r2,#0
;;;705    	for (tout = 0; tout < MII_WR_TOUT; tout++) 
000014  bf00              NOP      
000016  e006              B        |L11.38|
                  |L11.24|
;;;706    	{
;;;707    		if ((ETH->MACMIIAR & MMAR_MB) == 0) 
000018  4b05              LDR      r3,|L11.48|
00001a  691b              LDR      r3,[r3,#0x10]
00001c  f0030301          AND      r3,r3,#1
000020  b903              CBNZ     r3,|L11.36|
;;;708    		{
;;;709    			break;
000022  e003              B        |L11.44|
                  |L11.36|
000024  1c52              ADDS     r2,r2,#1              ;705
                  |L11.38|
000026  f5b22fa0          CMP      r2,#0x50000           ;705
00002a  d3f5              BCC      |L11.24|
                  |L11.44|
00002c  bf00              NOP      
;;;710    		}
;;;711    	}
;;;712    }
00002e  bd10              POP      {r4,pc}
;;;713    
                          ENDP

                  |L11.48|
                          DCD      0x40028000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  Rx_Desc
                          %        64
                  Tx_Desc
                          %        32
                  rx_buf
                          %        6144
                  tx_buf
                          %        3072

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  3d3d3d3d          DCB      "======================================================="
000004  3d3d3d3d
000008  3d3d3d3d
00000c  3d3d3d3d
000010  3d3d3d3d
000014  3d3d3d3d
000018  3d3d3d3d
00001c  3d3d3d3d
000020  3d3d3d3d
000024  3d3d3d3d
000028  3d3d3d3d
00002c  3d3d3d3d
000030  3d3d3d3d
000034  3d3d3d  
000037  3d3d3d3d          DCB      "========\r\n",0
00003b  3d3d3d3d
00003f  0d0a00  

                          AREA ||.data||, DATA, ALIGN=0

                  g_ucEthLinkStatus
000000  00                DCB      0x00
                  TxBufIndex
000001  00                DCB      0x00
                  RxBufIndex
000002  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\RL-ARM\\Driver\\ETH_STM32F4xx.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_ETH_STM32F4xx_c_814deff3____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_ETH_STM32F4xx_c_814deff3____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_ETH_STM32F4xx_c_814deff3____REVSH|
#line 144
|__asm___15_ETH_STM32F4xx_c_814deff3____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_ETH_STM32F4xx_c_814deff3____RRX|
#line 300
|__asm___15_ETH_STM32F4xx_c_814deff3____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
