; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\stm32f4xx_pwr.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\stm32f4xx_pwr.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\RL-ARM\Driver -I..\..\RL-ARM\Config -I..\..\RL-ARM\RL-RTX\inc -I..\..\User\libapp -I..\..\User\bsp\inc -I..\..\User\bsp -I..\..\User -I..\..\Libraries\STM32_USB_Device_Library\Class\dfu\inc -I..\..\Libraries\STM32_USB_Device_Library\Core\inc -D__MICROLIB -D__UVISION_VERSION=518 -D_RTE_ -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx --omf_browse=.\flash\obj\stm32f4xx_pwr.crf ..\..\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_pwr.c]
                          THUMB

                          AREA ||i.PWR_BackupAccessCmd||, CODE, READONLY, ALIGN=2

                  PWR_BackupAccessCmd PROC
;;;178      */
;;;179    void PWR_BackupAccessCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L1.8|
;;;180    {
;;;181      /* Check the parameters */
;;;182      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;183      
;;;184      *(__IO uint32_t *) CR_DBP_BB = (uint32_t)NewState;
000002  6208              STR      r0,[r1,#0x20]
;;;185    }
000004  4770              BX       lr
;;;186    
                          ENDP

000006  0000              DCW      0x0000
                  |L1.8|
                          DCD      0x420e0000

                          AREA ||i.PWR_BackupRegulatorCmd||, CODE, READONLY, ALIGN=2

                  PWR_BackupRegulatorCmd PROC
;;;410      */
;;;411    void PWR_BackupRegulatorCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L2.8|
;;;412    {
;;;413      /* Check the parameters */
;;;414      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;415    
;;;416      *(__IO uint32_t *) CSR_BRE_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;417    }
000004  4770              BX       lr
;;;418    
                          ENDP

000006  0000              DCW      0x0000
                  |L2.8|
                          DCD      0x420e00a4

                          AREA ||i.PWR_ClearFlag||, CODE, READONLY, ALIGN=2

                  PWR_ClearFlag PROC
;;;1003     */
;;;1004   void PWR_ClearFlag(uint32_t PWR_FLAG)
000000  4903              LDR      r1,|L3.16|
;;;1005   {
;;;1006     /* Check the parameters */
;;;1007     assert_param(IS_PWR_CLEAR_FLAG(PWR_FLAG));
;;;1008     
;;;1009   #if defined (STM32F427_437xx) || defined (STM32F429_439xx)
;;;1010     if (PWR_FLAG != PWR_FLAG_UDRDY)
;;;1011     {
;;;1012       PWR->CR |=  PWR_FLAG << 2;
;;;1013     }
;;;1014     else
;;;1015     {
;;;1016       PWR->CSR |= PWR_FLAG_UDRDY;
;;;1017     }
;;;1018   #endif /* STM32F427_437xx ||  STM32F429_439xx */
;;;1019   
;;;1020   #if defined (STM32F40_41xxx) || defined (STM32F401xx) || defined (STM32F411xE) 
;;;1021     PWR->CR |=  PWR_FLAG << 2;
000002  6809              LDR      r1,[r1,#0]
000004  ea410180          ORR      r1,r1,r0,LSL #2
000008  4a01              LDR      r2,|L3.16|
00000a  6011              STR      r1,[r2,#0]
;;;1022   #endif /* STM32F40_41xxx  || STM32F401xx || STM32F411xE */
;;;1023   }
00000c  4770              BX       lr
;;;1024   
                          ENDP

00000e  0000              DCW      0x0000
                  |L3.16|
                          DCD      0x40007000

                          AREA ||i.PWR_DeInit||, CODE, READONLY, ALIGN=1

                  PWR_DeInit PROC
;;;163      */
;;;164    void PWR_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;165    {
;;;166      RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, ENABLE);
000002  2101              MOVS     r1,#1
000004  0708              LSLS     r0,r1,#28
000006  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;167      RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, DISABLE);
00000a  2100              MOVS     r1,#0
00000c  f04f5080          MOV      r0,#0x10000000
000010  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;168    }
000014  bd10              POP      {r4,pc}
;;;169    
                          ENDP


                          AREA ||i.PWR_EnterSTANDBYMode||, CODE, READONLY, ALIGN=2

                  PWR_EnterSTANDBYMode PROC
;;;915      */
;;;916    void PWR_EnterSTANDBYMode(void)
000000  4807              LDR      r0,|L5.32|
;;;917    {
;;;918      /* Select STANDBY mode */
;;;919      PWR->CR |= PWR_CR_PDDS;
000002  6800              LDR      r0,[r0,#0]
000004  f0400002          ORR      r0,r0,#2
000008  4905              LDR      r1,|L5.32|
00000a  6008              STR      r0,[r1,#0]
;;;920      
;;;921      /* Set SLEEPDEEP bit of Cortex System Control Register */
;;;922      SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
00000c  4805              LDR      r0,|L5.36|
00000e  6800              LDR      r0,[r0,#0]
000010  f0400004          ORR      r0,r0,#4
000014  4903              LDR      r1,|L5.36|
000016  6008              STR      r0,[r1,#0]
;;;923      
;;;924      /* This option is used to ensure that store operations are completed */
;;;925    #if defined ( __CC_ARM   )
;;;926      __force_stores();
000018  bf00              NOP      
00001a  bf00              NOP      
;;;927    #endif
;;;928      /* Request Wait For Interrupt */
;;;929      __WFI();
00001c  bf30              WFI      
;;;930    }
00001e  4770              BX       lr
;;;931    
                          ENDP

                  |L5.32|
                          DCD      0x40007000
                  |L5.36|
                          DCD      0xe000ed10

                          AREA ||i.PWR_EnterSTOPMode||, CODE, READONLY, ALIGN=2

                  PWR_EnterSTOPMode PROC
;;;802      */
;;;803    void PWR_EnterSTOPMode(uint32_t PWR_Regulator, uint8_t PWR_STOPEntry)
000000  b510              PUSH     {r4,lr}
;;;804    {
000002  4602              MOV      r2,r0
;;;805      uint32_t tmpreg = 0;
000004  2000              MOVS     r0,#0
;;;806      
;;;807      /* Check the parameters */
;;;808      assert_param(IS_PWR_REGULATOR(PWR_Regulator));
;;;809      assert_param(IS_PWR_STOP_ENTRY(PWR_STOPEntry));
;;;810      
;;;811      /* Select the regulator state in STOP mode ---------------------------------*/
;;;812      tmpreg = PWR->CR;
000006  4b0d              LDR      r3,|L6.60|
000008  6818              LDR      r0,[r3,#0]
;;;813      /* Clear PDDS and LPDS bits */
;;;814      tmpreg &= CR_DS_MASK;
00000a  f6404303          MOV      r3,#0xc03
00000e  4398              BICS     r0,r0,r3
;;;815      
;;;816      /* Set LPDS, MRLVDS and LPLVDS bits according to PWR_Regulator value */
;;;817      tmpreg |= PWR_Regulator;
000010  4310              ORRS     r0,r0,r2
;;;818      
;;;819      /* Store the new value */
;;;820      PWR->CR = tmpreg;
000012  4b0a              LDR      r3,|L6.60|
000014  6018              STR      r0,[r3,#0]
;;;821      
;;;822      /* Set SLEEPDEEP bit of Cortex System Control Register */
;;;823      SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
000016  4b0a              LDR      r3,|L6.64|
000018  681b              LDR      r3,[r3,#0]
00001a  f0430304          ORR      r3,r3,#4
00001e  4c08              LDR      r4,|L6.64|
000020  6023              STR      r3,[r4,#0]
;;;824      
;;;825      /* Select STOP mode entry --------------------------------------------------*/
;;;826      if(PWR_STOPEntry == PWR_STOPEntry_WFI)
000022  2901              CMP      r1,#1
000024  d101              BNE      |L6.42|
;;;827      {   
;;;828        /* Request Wait For Interrupt */
;;;829        __WFI();
000026  bf30              WFI      
000028  e000              B        |L6.44|
                  |L6.42|
;;;830      }
;;;831      else
;;;832      {
;;;833        /* Request Wait For Event */
;;;834        __WFE();
00002a  bf20              WFE      
                  |L6.44|
;;;835      }
;;;836      /* Reset SLEEPDEEP bit of Cortex System Control Register */
;;;837      SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);  
00002c  4b04              LDR      r3,|L6.64|
00002e  681b              LDR      r3,[r3,#0]
000030  f0230304          BIC      r3,r3,#4
000034  4c02              LDR      r4,|L6.64|
000036  6023              STR      r3,[r4,#0]
;;;838    }
000038  bd10              POP      {r4,pc}
;;;839    
                          ENDP

00003a  0000              DCW      0x0000
                  |L6.60|
                          DCD      0x40007000
                  |L6.64|
                          DCD      0xe000ed10

                          AREA ||i.PWR_EnterUnderDriveSTOPMode||, CODE, READONLY, ALIGN=2

                  PWR_EnterUnderDriveSTOPMode PROC
;;;866      */
;;;867    void PWR_EnterUnderDriveSTOPMode(uint32_t PWR_Regulator, uint8_t PWR_STOPEntry)
000000  b510              PUSH     {r4,lr}
;;;868    {
000002  4602              MOV      r2,r0
;;;869      uint32_t tmpreg = 0;
000004  2000              MOVS     r0,#0
;;;870      
;;;871      /* Check the parameters */
;;;872      assert_param(IS_PWR_REGULATOR_UNDERDRIVE(PWR_Regulator));
;;;873      assert_param(IS_PWR_STOP_ENTRY(PWR_STOPEntry));
;;;874      
;;;875      /* Select the regulator state in STOP mode ---------------------------------*/
;;;876      tmpreg = PWR->CR;
000006  4b0d              LDR      r3,|L7.60|
000008  6818              LDR      r0,[r3,#0]
;;;877      /* Clear PDDS and LPDS bits */
;;;878      tmpreg &= CR_DS_MASK;
00000a  f6404303          MOV      r3,#0xc03
00000e  4398              BICS     r0,r0,r3
;;;879      
;;;880      /* Set LPDS, MRLUDS and LPLUDS bits according to PWR_Regulator value */
;;;881      tmpreg |= PWR_Regulator;
000010  4310              ORRS     r0,r0,r2
;;;882      
;;;883      /* Store the new value */
;;;884      PWR->CR = tmpreg;
000012  4b0a              LDR      r3,|L7.60|
000014  6018              STR      r0,[r3,#0]
;;;885      
;;;886      /* Set SLEEPDEEP bit of Cortex System Control Register */
;;;887      SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
000016  4b0a              LDR      r3,|L7.64|
000018  681b              LDR      r3,[r3,#0]
00001a  f0430304          ORR      r3,r3,#4
00001e  4c08              LDR      r4,|L7.64|
000020  6023              STR      r3,[r4,#0]
;;;888      
;;;889      /* Select STOP mode entry --------------------------------------------------*/
;;;890      if(PWR_STOPEntry == PWR_STOPEntry_WFI)
000022  2901              CMP      r1,#1
000024  d101              BNE      |L7.42|
;;;891      {   
;;;892        /* Request Wait For Interrupt */
;;;893        __WFI();
000026  bf30              WFI      
000028  e000              B        |L7.44|
                  |L7.42|
;;;894      }
;;;895      else
;;;896      {
;;;897        /* Request Wait For Event */
;;;898        __WFE();
00002a  bf20              WFE      
                  |L7.44|
;;;899      }
;;;900      /* Reset SLEEPDEEP bit of Cortex System Control Register */
;;;901      SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);  
00002c  4b04              LDR      r3,|L7.64|
00002e  681b              LDR      r3,[r3,#0]
000030  f0230304          BIC      r3,r3,#4
000034  4c02              LDR      r4,|L7.64|
000036  6023              STR      r3,[r4,#0]
;;;902    }
000038  bd10              POP      {r4,pc}
;;;903    
                          ENDP

00003a  0000              DCW      0x0000
                  |L7.60|
                          DCD      0x40007000
                  |L7.64|
                          DCD      0xe000ed10

                          AREA ||i.PWR_FlashPowerDownCmd||, CODE, READONLY, ALIGN=2

                  PWR_FlashPowerDownCmd PROC
;;;656      */
;;;657    void PWR_FlashPowerDownCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L8.8|
;;;658    {
;;;659      /* Check the parameters */
;;;660      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;661    
;;;662      *(__IO uint32_t *) CR_FPDS_BB = (uint32_t)NewState;
000002  6248              STR      r0,[r1,#0x24]
;;;663    }
000004  4770              BX       lr
;;;664    
                          ENDP

000006  0000              DCW      0x0000
                  |L8.8|
                          DCD      0x420e0000

                          AREA ||i.PWR_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  PWR_GetFlagStatus PROC
;;;975      */
;;;976    FlagStatus PWR_GetFlagStatus(uint32_t PWR_FLAG)
000000  4601              MOV      r1,r0
;;;977    {
;;;978      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;979      
;;;980      /* Check the parameters */
;;;981      assert_param(IS_PWR_GET_FLAG(PWR_FLAG));
;;;982      
;;;983      if ((PWR->CSR & PWR_FLAG) != (uint32_t)RESET)
000004  4a03              LDR      r2,|L9.20|
000006  6852              LDR      r2,[r2,#4]
000008  400a              ANDS     r2,r2,r1
00000a  b10a              CBZ      r2,|L9.16|
;;;984      {
;;;985        bitstatus = SET;
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L9.18|
                  |L9.16|
;;;986      }
;;;987      else
;;;988      {
;;;989        bitstatus = RESET;
000010  2000              MOVS     r0,#0
                  |L9.18|
;;;990      }
;;;991      /* Return the flag status */
;;;992      return bitstatus;
;;;993    }
000012  4770              BX       lr
;;;994    
                          ENDP

                  |L9.20|
                          DCD      0x40007000

                          AREA ||i.PWR_MainRegulatorModeConfig||, CODE, READONLY, ALIGN=2

                  PWR_MainRegulatorModeConfig PROC
;;;432      */
;;;433    void PWR_MainRegulatorModeConfig(uint32_t PWR_Regulator_Voltage)
000000  4601              MOV      r1,r0
;;;434    {
;;;435      uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;436    	
;;;437      /* Check the parameters */
;;;438      assert_param(IS_PWR_REGULATOR_VOLTAGE(PWR_Regulator_Voltage));
;;;439    
;;;440      tmpreg = PWR->CR;
000004  4a03              LDR      r2,|L10.20|
000006  6810              LDR      r0,[r2,#0]
;;;441      
;;;442      /* Clear VOS[15:14] bits */
;;;443      tmpreg &= CR_VOS_MASK;
000008  f4204040          BIC      r0,r0,#0xc000
;;;444      
;;;445      /* Set VOS[15:14] bits according to PWR_Regulator_Voltage value */
;;;446      tmpreg |= PWR_Regulator_Voltage;
00000c  4308              ORRS     r0,r0,r1
;;;447      
;;;448      /* Store the new value */
;;;449      PWR->CR = tmpreg;
00000e  6010              STR      r0,[r2,#0]
;;;450    }
000010  4770              BX       lr
;;;451    
                          ENDP

000012  0000              DCW      0x0000
                  |L10.20|
                          DCD      0x40007000

                          AREA ||i.PWR_OverDriveCmd||, CODE, READONLY, ALIGN=2

                  PWR_OverDriveCmd PROC
;;;467      */
;;;468    void PWR_OverDriveCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L11.8|
;;;469    {
;;;470      /* Check the parameters */
;;;471      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;472      
;;;473      /* Set/Reset the ODEN bit to enable/disable the Over Drive mode */
;;;474      *(__IO uint32_t *) CR_ODEN_BB = (uint32_t)NewState;
000002  6408              STR      r0,[r1,#0x40]
;;;475    }
000004  4770              BX       lr
;;;476    
                          ENDP

000006  0000              DCW      0x0000
                  |L11.8|
                          DCD      0x420e0000

                          AREA ||i.PWR_OverDriveSWCmd||, CODE, READONLY, ALIGN=2

                  PWR_OverDriveSWCmd PROC
;;;485      */
;;;486    void PWR_OverDriveSWCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L12.8|
;;;487    {
;;;488      /* Check the parameters */
;;;489      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;490    
;;;491      /* Set/Reset the ODSWEN bit to enable/disable the Over Drive switching mode */
;;;492      *(__IO uint32_t *) CR_ODSWEN_BB = (uint32_t)NewState;
000002  6448              STR      r0,[r1,#0x44]
;;;493    }
000004  4770              BX       lr
;;;494    
                          ENDP

000006  0000              DCW      0x0000
                  |L12.8|
                          DCD      0x420e0000

                          AREA ||i.PWR_PVDCmd||, CODE, READONLY, ALIGN=2

                  PWR_PVDCmd PROC
;;;251      */
;;;252    void PWR_PVDCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L13.8|
;;;253    {
;;;254      /* Check the parameters */
;;;255      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;256      
;;;257      *(__IO uint32_t *) CR_PVDE_BB = (uint32_t)NewState;
000002  6108              STR      r0,[r1,#0x10]
;;;258    }
000004  4770              BX       lr
;;;259    
                          ENDP

000006  0000              DCW      0x0000
                  |L13.8|
                          DCD      0x420e0000

                          AREA ||i.PWR_PVDLevelConfig||, CODE, READONLY, ALIGN=2

                  PWR_PVDLevelConfig PROC
;;;226      */
;;;227    void PWR_PVDLevelConfig(uint32_t PWR_PVDLevel)
000000  4601              MOV      r1,r0
;;;228    {
;;;229      uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;230      
;;;231      /* Check the parameters */
;;;232      assert_param(IS_PWR_PVD_LEVEL(PWR_PVDLevel));
;;;233      
;;;234      tmpreg = PWR->CR;
000004  4a03              LDR      r2,|L14.20|
000006  6810              LDR      r0,[r2,#0]
;;;235      
;;;236      /* Clear PLS[7:5] bits */
;;;237      tmpreg &= CR_PLS_MASK;
000008  f02000e0          BIC      r0,r0,#0xe0
;;;238      
;;;239      /* Set PLS[7:5] bits according to PWR_PVDLevel value */
;;;240      tmpreg |= PWR_PVDLevel;
00000c  4308              ORRS     r0,r0,r1
;;;241      
;;;242      /* Store the new value */
;;;243      PWR->CR = tmpreg;
00000e  6010              STR      r0,[r2,#0]
;;;244    }
000010  4770              BX       lr
;;;245    
                          ENDP

000012  0000              DCW      0x0000
                  |L14.20|
                          DCD      0x40007000

                          AREA ||i.PWR_UnderDriveCmd||, CODE, READONLY, ALIGN=2

                  PWR_UnderDriveCmd PROC
;;;512      */
;;;513    void PWR_UnderDriveCmd(FunctionalState NewState)
000000  b130              CBZ      r0,|L15.16|
;;;514    {
;;;515      /* Check the parameters */
;;;516      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;517    
;;;518      if (NewState != DISABLE)
;;;519      {
;;;520        /* Set the UDEN[1:0] bits to enable the Under Drive mode */
;;;521        PWR->CR |= (uint32_t)PWR_CR_UDEN;
000002  4907              LDR      r1,|L15.32|
000004  6809              LDR      r1,[r1,#0]
000006  f4412140          ORR      r1,r1,#0xc0000
00000a  4a05              LDR      r2,|L15.32|
00000c  6011              STR      r1,[r2,#0]
00000e  e005              B        |L15.28|
                  |L15.16|
;;;522      }
;;;523      else
;;;524      {
;;;525        /* Reset the UDEN[1:0] bits to disable the Under Drive mode */
;;;526        PWR->CR &= (uint32_t)(~PWR_CR_UDEN);
000010  4903              LDR      r1,|L15.32|
000012  6809              LDR      r1,[r1,#0]
000014  f4212140          BIC      r1,r1,#0xc0000
000018  4a01              LDR      r2,|L15.32|
00001a  6011              STR      r1,[r2,#0]
                  |L15.28|
;;;527      }
;;;528    }
00001c  4770              BX       lr
;;;529    
                          ENDP

00001e  0000              DCW      0x0000
                  |L15.32|
                          DCD      0x40007000

                          AREA ||i.PWR_WakeUpPinCmd||, CODE, READONLY, ALIGN=2

                  PWR_WakeUpPinCmd PROC
;;;285      */
;;;286    void PWR_WakeUpPinCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L16.8|
;;;287    {
;;;288      /* Check the parameters */  
;;;289      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;290    
;;;291      *(__IO uint32_t *) CSR_EWUP_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;292    }
000004  4770              BX       lr
;;;293    #endif /* STM32F40_41xxx || STM32F427_437xx || STM32F429_439xx || STM32F401xx || STM32F411xE */
                          ENDP

000006  0000              DCW      0x0000
                  |L16.8|
                          DCD      0x420e00a0

;*** Start embedded assembler ***

#line 1 "..\\..\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_pwr.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_pwr_c_0c2a8b75____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f4xx_pwr_c_0c2a8b75____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_pwr_c_0c2a8b75____REVSH|
#line 144
|__asm___15_stm32f4xx_pwr_c_0c2a8b75____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_pwr_c_0c2a8b75____RRX|
#line 300
|__asm___15_stm32f4xx_pwr_c_0c2a8b75____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
